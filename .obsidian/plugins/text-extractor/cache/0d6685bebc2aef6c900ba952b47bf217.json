{"path":"docs/课程/编译原理/课件/Chapter_8.pdf","text":"许畅 南京大学计算机系 2024年春季 第八章 代码生成 版权所有 南京大学计算机科学与技术系 许畅 2024春季版 主要内容 • 代码生成器的设计 • 目标语言 • 目标代码中的地址 • 基本块和流图 • 基本块优化 • 代码生成器 • 寄存器分配 • 选择指令 2 代码生成器的位置 • 根据中间表示 (IR) 生成代码 • 代码生成器之前可能有一个优化组件 • 代码生成器的三个任务 – 指令选择：选择适当的指令实现IR语句 – 寄存器分配和指派：把哪个值放在哪个寄存器中 – 指令排序：按照什么顺序安排指令执行 3 要解决的问题 • 正确性：正确的机器指令 • 易于实现、测试和维护 • 输入IR的选择 – 四元式、三元式、字节代码、堆栈机代码、后缀表示、 抽象语法树、DAG图、… • 输出 – RISC (目标机)、CISC (寻址方式) – 可重定向代码、汇编语言 4 目标机模型 • 使用三地址机器的模型 • 指令 – 加载：LD dst, addr (把地址addr中的内容加载到dst所指 的寄存器) – 保存：ST x, r (把寄存器r中的内容保存到x中) – 计算：OP dst, src1, src2 (把src1和src2中的值运算后将结 果存放到dst中) – 无条件跳转：BR L (控制流转向标号L的指令) – 条件跳转：Bcond r, L (对r中的值进行测试，如果为真 则转向L) 5 寻址模式 • 变量x：指向分配x的内存位置 • a(r)：地址是a的左值加上寄存器r中的值 • constant(r)：寄存器r中内容加上前面的常数即其 地址 • *r：寄存器r的内容所表示的位置上存放的内容位 置 • *constant(r)：寄存器r中内容加上常数所代表的位 置上的内容所表示的位置 • 常数#constant 6 例子 (1) • x = y – z – LD R1, y // R1 = y – LD R2, z // R2 = z – SUB R1, R1, R2 // R1 = R1 – R2 – ST x, R1 // x = R1 • b = a[i] – LD R1, i // R1 = i – MUL R1, R1, 8 // R1 = R1 * 8 (8字节长元素) – LD R2, a(R1) // R2 = contents(a + contents(R1)) – ST b, R2 // b = R2 7 例子 (2) • a[j] = c – LD R1, c // R1 = c – LD R2, j // R2 = j – MUL R2, R2, 8 // R2 = R2 * 8 (8字节长元素) – ST a(R2), R1 // contents(a + contents(R2)) = R1 • x = *p – LD R1, p // R1 = p – LD R2, 0(R1) // R2 = contents(0 + contents(R1)) – ST x, R2 // x = R2 8 例子 (3) • *p = y – LD R1, p // R1 = p – LD R2, y // R2 = y – ST 0(R1), R2 // contents(0 + contents(R1)) = R2 • if x < y goto L – LD R1, x // R1 = x – LD R2, y // R2 = y – SUB R1, R1, R2 // R1 = R1 – R2 – BLTZ R1, M // if R1 < 0 jump to M 9 程序和指令的代价 • 不同的目的有不同的度量 – 最短编译时间、运行时间、目标程序大小、能耗 • 不可判定一个目标程序是否最优 • 假设每个指令有固定的代价，设定为1加上运算分 量寻址模式的代价 – LD R0, R1：代价为1 – LD R0, M：代价是2 – LD R1, *100(R2)：代价为2 10 目标代码中的地址 • 如何为过程调用和返回生成代码？ – 静态分配 (活动记录) – 栈式分配 (活动记录) • 如何将IR中的名字 (过程名或变量名) 转换成为目 标代码中的地址？ – 不同区域中的名字采用不同的寻址方式 11 活动记录的静态分配 • 每个过程静态地分配一个数据区域，其开始位置 用staticArea表示 • call callee的实现 – ST callee.staticArea, #here + 20 // 存放返回地址 – BR callee.codeArea • callee中的语句return – BR *callee.staticArea 12 例子 • 三地址代码 – c的代码 • action1 • call p • action2 • halt – p的代码 • action3 • return 13 活动记录的栈式分配 • 寄存器SP指向栈顶 • 第一个过程 (main) 初始化栈区 • 过程调用指令序列 – ADD SP, SP, #caller.recordSize // 增大栈指针 – ST 0(SP), #here + 16 // 保存返回地址 – BR callee.codeArea // 转移到被调用者 • 返回指令序列 – BR *0(SP) // 被调用者执行，返回调用者 – SUB SP, SP, #caller.recordSize // 调用者减小栈指针 14 例子 15 m调用q，q调用p 名字的运行时刻地址 • 在三地址语句中使用名字 (实际上是指向符号表条 目) 来引用变量 • 语句x = 0 – 如果x分配在静态区域，且静态区开始位置为static • static[12] = 0 LD 112, #0 // static = 100 – 如果x分配在栈区，且相对地址为12，则 • LD 12(SP), #0 16 基本块和流图 • 中间代码的流图 (flow graph) 表示法 – 中间代码划分成为基本块 (basic block) • 控制流只能从基本块的第一条指令进入 • 除基本块的最后一条指令外，控制流不会跳转/停机 – 流图的结点是基本块，流图的边指明了哪些基本块可 以跟在一个基本块之后运行 • 流图可以作为优化的基础 – 它指出了基本块之间的控制流 – 可以根据流图了解到一个值是否会被使用等信息 17 划分基本块的算法 • 输入：三地址指令序列 • 输出：基本块的列表 • 方法 – 确定首指令leader (基本块的第一个指令) • 第一个三地址指令 • 任意一个 (条件或无条件) 转移指令的目标指令 • 紧跟在一个 (条件或无条件) 转移指令之后的指令 – 确定基本块 • 每个首指令对应于一个基本块：从首指令开始到下一个首指令 18 例子 • 第一个指令 – 1 • 跳转指令的目标指令 – 3, 2, 13 • 跳转指令的下一条指令 – 10, 12 • 基本块 – 1-1, 2-2, 3-9, 10-11, 12-12, 13-17 19 后续使用信息 • 变量值的使用 (use) – 三地址语句i向变量x赋值，如果另一个语句j的运算分 量为x，且从i开始有一条路径到达j，且路径上没有对x 赋值，那么j就使用了i处计算得到的x的值 – 我们说变量x在语句i后的程序点上活跃 (live) • 程序执行完语句i时，x中存放的值将被后面的语句使用 • 不活跃是指变量的值不会被使用，而不是变量不会被使用 • 这些信息可以用于代码生成 – 如果x在i处不活跃，且x占用了一个寄存器，我们可以 把这个寄存器用于其它目的 20 确定基本块中的活跃性、后续使用 • 输入 – 基本块B，开始时B中的所有非临时变量都是活跃的 • 输出 – 各个语句i上变量的活跃性、后续使用信息 • 方法 – 从B的最后一个语句开始反向扫描 – 对于每个语句i：x = y + z • 令语句i和x、y、z的当前活跃性信息/使用信息关联 • 设置x为“不活跃”和“无后续使用” • 设置y和z为“活跃”，并指明它们的下一次使用设置为语句i 21 例子 • i, j, a非临时变量 (出口处活跃)，其余变量不活跃 – 8) i, j, a活跃，j在8上被使用 – 7) i, j, a, t4活跃，a和t4被7使用 – 6) i, j, a, t3活跃，t4不活跃，t3被6使用 – 5) i, j, a, t2活跃，t4, t3不活跃，t2被5使用 – 4) i, j, a, t1活跃，t4, t3, t2不活跃，t1和j被4使用 – 3) i, j, a活跃，t4, t3, t2, t1不活跃，i被3使用 22 流图的构造 • 流图的结点是基本块 – 两个结点B和C之间有一条有向边 iff 基本块C的第一个 指令可能在B的最后一个指令之后执行 • 存在边的原因 – B的结尾指令是一条跳转到C的开头的条件/无条件语句 – C紧跟在B之后，且B的结尾不是无条件跳转语句 – 称B是C的前驱 (predecessor)，C是B的后继 (successor) • 入口 (entry) /出口 (exit) 结点 – 不和任何中间指令对应；入口到第一条指令有一条边； 任何可能最后执行的基本块到出口有一条边 23 流图的例子 • 因跳转而生成的边 – B3 → B3 – B4 → B2 – B6 → B6 • 因为顺序而生成的边 – 其它 24 循环 • 程序的大部分运行时间花费在循环上，因此循环 是识别的重点 (优化的目标) • 循环的定义 – 循环L是一个结点集合 – 存在一个循环入口 (loop entry) 结点，是唯一的前驱可 以在循环L之外的结点，到达其余结点的路径必然先经 过这个入口结点 – 其余结点都存在到达入口结点的非空路径，且路径都 在L中 25 循环的例子 • 循环 – { B3 } – { B2, B3, B4 } – { B6 } • 对于{ B2, B3, B4 }的解释 – B2为入口结点 – B1, B5, B6不在循环内 • 到达B1可不经过B2 • B5, B6没有到达B2的路径 26 基本块的优化 • 针对基本块的优化可以有很好的效果 (局部优化) • DAG图可反映变量及其值对其他变量的依赖关系 • 构造方法 – 每个变量都有一个对应的DAG结点表示其初始值 – 每个语句s有一个相关的结点N，代表此计算得到的值 • N的子结点对应于 (得到其运算分量当前值的) 其它语句 • N的标号是s中的运算符，同时还有一组变量被关联到N，表示 s是最晚对这些变量进行定值的语句 27 DAG图的构造 • 为基本块中出现的每个变量建立结点 (表示初始 值)，各变量和相应结点关联 • 顺序扫描各三地址指令，进行如下处理 – 指令x = y op z • 为该指令建立结点N，标号为op，令x和N关联 • N的子结点为y和z当前关联的结点 – 指令x = y • 假设y关联到N，那么x现在也关联到N • 扫描结束后，对所有在出口处活跃的变量x，将x 所关联的结点设置为输出结点 (output node) 28 例子 • 指令序列 – a = b + c – b = a – d – c = b + c • 过程 – 结点b0、c0和d0对应于b、c和d的初始值 – a = b + c：构造第一个加法结点，a与之关联 – b = a – d：构造减法结点，b与之关联 – c = b + c：构造第二个加法结点，c与之关联 (注意第一 个子结点对应于减法结点) 29 DAG的作用 • DAG图描述了基本块运行时各变量的值 (和初始 值) 之间的关系 • 以DAG为基础，对代码进行转换 – 寻找局部公共子表达式 (local common subexpression) – 消除死代码 (dead code) – 代数恒等式的使用 – 数组引用的表示 – 指针赋值和过程调用 30 局部公共子表达式 • 局部公共子表达式的发现 – 建立某个结点M之前，检查是否存在一个结点N，它和 M具有相同的运算符和子结点 (顺序也相同) – 如果存在，则不需要生成新的结点，用N代表M • 例如 – a = b + c – b = a – d – c = b + c – d = a – d • 注意：两个b + c不是公共子表达式 (但a – d是) 31 消除死代码 • 在DAG图上消除没有附加活跃变量的根结点，即 消除死代码 • 如果图中c、e不是活跃变量 (但a、b是)，则可以 删除标号为e、c的结点 32 基于代数恒等式的优化 • 恒等式 – x + 0 = 0 + x = x, x – 0 = x, x * 1 = 1 * x = x, x / 1 = x • 强度消减 (reduction in strength) – x2 = x * x, 2 * x = x + x, x / 2 = x * 0.5 • 常量合并/折叠 (constant folding) – 2 * 3.14可以用6.28替换 • 通用代数转换规则 – 交换律和结合律等，如x * y = y * x • 实现这些优化，只需在DAG图上寻找特定的模式 33 数组引用 • a[j]可能改变a[i]的值，因此不能像普通运算符一 样构造结点 – x = a[i] a[j] = y z = a[i] • 从数组取值的运算x = a[i]对应于=[]的结点 – 这个结点的左右子节点是数组初始值a0和下标i – 变量x是这个结点的标号之一 • 对数组赋值的运算a[j] = y对应于[]=的结点 – 这个结点的三个子节点分别表示a0、j和y – 杀死所有依赖于a0的变量 34 数组引用DAG的例子 • 设a是数组，b是指针 – b = 12 + a – x = b[i] – b[j] = y • 一个结点被杀死，意 味着它不能被复用 – 考虑再有指令m = b[i] 35 b x 指针赋值/过程调用 • 通过指针进行取值/赋值：x = *p、*q = y – x使用了任意变量，因此无法消除死代码 – *q = y对任意变量赋值，因此杀死了全部其他结点 • 可通过 (全局/局部) 指针分析部分地解决这个问题 • 过程调用也类似，必须安全地假设它 – 使用了可访问范围内的所有变量 – 修改了可访问范围内的所有变量 36 从DAG到基本块的重组 • 重组的方法 – 每个结点构造一个三地址语句，计算对应的值 – 结果应该尽量赋给一个活跃的变量 – 如果结点有多个关联的变量，则需要用复制语句进行 赋值 37 例子 • 根据DAG构造时结点产生的顺序 – a = b + c – d = a – d – b = d – c = d + c 38 重组的规则 • 注意求值顺序 – 指令顺序必须遵守DAG中结点的顺序 – 对数组赋值 (write) 要跟在原来之前的赋值/求值之后 – 对数组求值 (read) 要跟在原来之前的赋值指令之后 – 对变量的使用必须跟在所有原来在它之前的过程调用 和指针间接赋值之后 – 任何过程调用或指针间接赋值必须跟在原来在它之前 的变量求值之后 • 即保证 – 如果两个指令之间相互影响，它们的顺序就不该改变 39 代码生成器 • 根据三地址指令序列生成机器指令 – 假设每个三地址指令只有一个对应的机器指令 – 有一组寄存器用于计算基本块内部的值 • 主要的目标是减少加载 (LD) 和保存 (ST) 指令， 即最大限度地利用寄存器 • 寄存器的使用方法 – 执行运算时，运算分量必须放在寄存器中 – 存放临时变量 – 存放全局的值 – 进行运行时刻管理 (比如栈顶指针) 40 算法的基本思想和数据结构 • 依次考虑各三地址指令，尽可能把值保留在寄存 器中，以减少寄存器/内存之间的数据交换 • 为一个三地址指令生成机器指令时 – 只有当运算分量不在寄存器中时，才从内存载入 – 尽量保证只有当寄存器中值不被使用时，才覆盖掉 • 数据结构 – 寄存器描述符 (register descriptor)：跟踪各个寄存器 都存放了哪些变量的当前值 – 地址描述符 (address descriptor)：各个变量的当前值 存放在哪些位置 (包括内存位置和寄存器) 上 41 代码生成算法 (1) • 重要子函数：getReg(I) – 根据寄存器描述符和地址描述符等数据流信息，为三 地址指令I选择最佳的寄存器 – 得到的机器指令的质量依赖于getReg函数选取寄存器的 算法 • 代码生成算法逐个处理三地址指令 42 代码生成算法 (2) • 运算语句：x = y + z – getReg(x = y + z)为x, y, z选择寄存器Rx, Ry, Rz – 检查Ry的寄存器描述符，如果y不在Ry中则生成指令 • LD Ry, y' // y'表示存放y值的当前位置 • 类似地确定是否生成LD Rz, z' – 生成指令ADD Rx, Ry, Rz • 复制语句：x = y – getReg(x = y)为x和y选择相同的寄存器 – 如果y不在Ry中，则生成指令LD Ry, y • 基本块的收尾 – 如果变量x活跃，且不在内存中，则生成指令ST x, Rx 43 代码生成算法 (3) • 代码生成同时更新寄存器和地址描述符 • 处理指令时生成的LD R, x – R的寄存器描述符：只包含x – x的地址描述符：R作为新位置加入到x的位置集合中 – 从任何不同于x的变量的地址描述符中删除R • 生成的ST x, R – x的地址描述符：包含自己的内存位置 (新增) 44 代码生成算法 (4) • ADD Rx, Ry, Rz – Rx的寄存器描述符：只包含x – x的地址描述符：只包含Rx (不包含x的内存位置) – 从任何不同于x的变量的地址描述符中删除Rx • 处理x = y时 – 如果生成LD Ry, y，按照第一个规则处理 – 把x加入到Ry的寄存器描述符中 (即Ry同时存放了x和y 的当前值) – x的地址描述符：只包含Ry (不包含x的内存位置) 45 例子 (1) • a、b、c、d在出口处活跃 • t、u、v是局部临时变量 46 t = a – b u = a – c v = t + u a = d d = v + u 例子 (2) 47 例子 (3) 48 getReg函数 (1) • 目标：减少LD/ST指令 • 任务：为运算分量和结果分配寄存器 • 为x = y op z的运算分量y和z分配寄存器 – 如果y已经在某个寄存器中，不需要进行处理，选择这 个寄存器作为Ry – 如果y不在寄存器中，且有空闲寄存器，选择一个空闲 寄存器作为Ry – 如果不在寄存器中，且没有空闲寄存器？ 49 getReg函数 (2) • 如果不在寄存器中，且没有空闲寄存器？ • 寻找一个寄存器R，其寄存器描述符表示v在R中 – 如果v的地址描述符表明还可以在别的地方找到v， DONE – v就是x (即结果)，且x不是运算分量z，DONE – 如果v在此之后不会被使用 (不活跃)，DONE – 溢出操作 (spill)：生成保存指令ST v, R并修改v的地址 描述符；如果R中存放了多个变量的值，那么需要生成 多条ST指令 50 getReg函数 (3) • 为x = y op z的结果x选择寄存器Rx的方法基本上和 上面要把y从内存LD时一样，但是 – 只存放x值的寄存器总是可接受的 – 如果y在指令之后不再使用，且Ry仅仅保存了y的值， 那么Ry同时也可以作为Rx (对z也一样) • 处理x = y时 – 先选择Ry – 然后让Rx = Ry 51 窥孔优化 • 窥孔优化 (peephole optimization)：使用一个滑 动窗口 (窥孔) 来检查目标指令，在窥孔内实现优 化 – 冗余指令消除 – 控制流优化 – 代数化简 – 机器特有指令的使用 52 冗余指令消除 • 多余的LD/ST指令 – LD R0, a – ST a, R0 // 无标号；可删除 • 级联跳转代码 – if debug == 1 goto L1; goto L2; L1: …; L2: …; • => if debug != 1 goto L2; L1: …; L2: …; – 如果已知debug一定是0，那么替换成为goto L2 53 控制流优化 • goto L1; … …; L1: goto L2 – => goto L2; … …; L1: goto L2 • if a < b goto L1; … … ; L1: goto L2 – => if a < b goto L2; … … ; L1: goto L2 54 代数化简和机器特有指令 • 应用代数恒等式 – 消除x = x + 0, x = x * 1, … – 用x * x替换x2 • 使用机器特有指令 – INC, DEC, … 55 寄存器分配和指派 • 寄存器分配 – 确定在程序的每个点上，哪个值应该存放在寄存器中 • 寄存器指派 – 各个值应该存放在哪个寄存器中 • 简单方法：把特定类型的值分配给特定的寄存器 – 数组基地址指派给一组寄存器，算术计算分配给一组 寄存器，栈顶指针分配一个寄存器，循环… – 缺点：寄存器的使用效率较低 56 全局寄存器分配 • 在循环中频繁使用的值存放在固定寄存器 – 分配固定多个寄存器来存放内部循环中最活跃的值 • 可以通过使用计数 (保存和加载成本) 的方法来估 算把一个变量放到寄存器中会带来多大好处，然 后根据这个估算来分配寄存器 57 树重写实现指令选择 • 在某些机器上，同一个三地址指令可以使用多种 机器指令实现，有时多个三地址指令可以使用一 个机器指令实现 • 指令选择 – 为实现中间表示形式中出现的运算符选择适当的机器 指令 – 用树来表示中间代码，按照特定的规则不断覆盖这棵 树并生成机器指令 58 例子 • a[i] = b + 1 – ind：把参数作为内存地址 – a, i：局部变量 – b：全局变量 – SP：栈顶指针 59 目标指令选择 • 通过应用一个树重写规则序列来生成 • 一组树重写规则被称为一个树翻译方案 (tree- translation scheme) • 树重写规则示例 60 一些重写规则 (1) 61 一些目标机器指令的树重写规则 一些重写规则 (2) 62 一些目标机器指令的树重写规则 覆盖重写过程 • 规则1)：{ LD R0, #a } • 规则7)：{ ADD R0, R0, SP } • 规则6)：{ ADD R0, R0, i(SP) } • 规则2)：{ LD R1, b } • 规则8)：{ INC R1 } • 规则4)：{ ST *R0, R1 } 63 树翻译方案的工作模式 • 给定一颗输入树，树重写规则中的模板被用来匹 配输入树的子树 • 如果找到一个匹配的模板，那么输入树中匹配的 子树将被替换为相应规则中的替换结点，并执行 相应的动作，这可能是生成相应的机器指令序列 • 不断匹配，直到这颗树被规约成单个结点，或找 不到匹配的模板为止 • 在此过程中生成的机器指令代码序列就是树翻译 方案作用于给定输入树而得到的输出 64 通过扫描进行模式匹配 • 如何完成树匹配？ – 把树重写规则替换成相应的上下文无关文法的产生式 – 产生式的右部是其指令模板的前缀表示 • 如果在某个时刻有多个模板可以匹配 – 匹配到大树优先 65","libVersion":"0.2.4","langs":""}