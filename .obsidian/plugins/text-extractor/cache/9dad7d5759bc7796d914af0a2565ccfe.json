{"path":"归档课程/数字逻辑与计算机组成/课件/第6章 运算（1）加法器.pdf","text":"回顾第11次课  未用状态分析(挂起/无法自启动)  定时分析(clk-Q时间、时钟周期、setup时间、hold时间)  典型时序逻辑部件：计数器、寄存器/通用寄存器组、移位寄存器 1 k：k位无符号二进制数，其真值 对应一个寄存器编号，且表示此 寄存器堆最多只能有2k个寄存器 n：代表每个寄存器内存放n位二 进制机器数（可以是无符号数、 补码、浮点数等等） 两个读口一个写口是最常用配置 2023/12/27 第一讲 基本运算部件 第二讲 定点数运算 第三讲 浮点数运算 第6章 运算方法和运算部件 回顾：计算机系统层次结构 数字逻辑 与 计算机组成 DL&CO RISC架构 CPU MM I/O 本章内容 前面章节内容 第一讲：基本运算部件 主 要 内 容  高级语言程序中涉及的运算（以C语言为例） • 整数算术运算、浮点数算术运算 • 按位、逻辑、移位、位扩展和位截断  串行进位加法器  并行进位加法器 • 全先行进位加法器 • 两级/多级先行进位加法器  带标志加法器  算术逻辑部件（ALU） 高级语言中的运算 高级语言程序中涉及的数据类型和运算 （以C语言为例） •无符号数，带符号整数， 浮点数，位串，字符 •算术运算 •按位、逻辑、移位、位扩展和位截断、比较 如何实现高级语言源程序中的运算？ 将各类表达式转换成指令序列 计算机执行指令来完成运算 0000 0010 0011 0010 0100 0000 0010 0000 control信号输入 信 息 输 入 信 息 输 出 指令+数据 int a,b=5,c=-8; a=b+c 为变量分配寄存器 把变量按类型编码 机器数放入寄存器 按类型完成运算 运算结果放入寄存器  Add $t0,$s1,$s2  0232 4020H 运算实 现逻辑 17号寄存器S1 18号寄存器S2 xx号寄存器 8号寄存器t0 …… …… a b c 这是MIPS汇编指令。 如果换成RISC-V呢？ 数据的运算  指令集中涉及的运算（如RISC-V指令系统提供的运算类指令） • 涉及的定点数运算 - 算术运算 • 带符号整数：取负 / 符号扩展 / 加 / 减 / 乘 / 除 / 算术移位 • 无符号整数：0扩展 / 加 / 减 / 乘 / 除 - 逻辑运算 • 逻辑操作：与 / 或 / 非 / … • 移位操作：逻辑左移 / 逻辑右移 • 涉及的浮点数运算：加、减、乘、除 所有运算都可由ALU或 加法器+移位器+多路选 择器+控制逻辑实现！ 以下介绍基本运算部件：加法器（串行→并行 ）→ 带标志加法器 → ALU 完全能够支持高级语 言对运算的所有需求 逻辑运算、移位、扩展和 截断等指令实现较容易， 算术运算指令实现较难！ 回顾： 半加器和全加器  全加器（Full Adder，简称FA） 输入为加数、被加数和低位进位Cin，输出为和F、进位Cout 逻辑符号 真值表 化简后： 全加器逻辑电路图 串行进位加法器 假定与/或门延迟为1，异或门为3， 则“和”与“进位”延迟为多少？ FA 全加器符号： 串行加法器的缺点： 进位按串行方式传递，速度慢！ 问题：n位串行加法器从C0到Cn的延 迟时间为多少？ 最后一位和数的延迟时间为多少？ 2n+1级门延迟！ (n=1、2的话还是需要6级) 2n级门延迟！ Sum延迟为6；Carryout延迟为2。 FA FAFA n位串行(行波)加法器： C0Cn 0 A,B,C0 1 2 C1 3 Ai ⊕Bi 4 C2 5 6 C3 F1，F2 7 F3 8 C4 9 F4 并行进位加法器（CLA）  为什么用先行进位方式？ 串行进位加法器采用串行逐级传递进位，电路延迟与位数成正比关系。 因此，现代计算机采用一种先行进位(Carry look ahead)方式。  如何产生先行进位？ 定义辅助函数：Gi=AiBi 进位生成函数 Pi=Ai+Bi 进位传递函数 通常把实现上述逻辑的电路称为进位生成/传递部件 全加逻辑方程：Fi=Ai⊕Bi⊕Ci-1 Ci=Gi+PiCi-1 (i=1,…n) 设n=4,则：C1=G1+P1C0 C2=G2+P2C1=G2+P2G1+P2P1C0 C3=G3+P3C2=G3+P3G2+P3P2G1+P3P2P1C0 C4=G4+P4C3=G4+P4G3+P4P3G2+P4P3P2G1+P4P3P2P1C0 由上式可知:各进位之间无等待，相互独立并同时产生。 通常把实现上述逻辑的电路称为4位先行进位部件（4位CLU） CLA加法器 Gi=XiYi Pi=Xi+Yi（或 Pi=Xi⊕Yi ） Fi=Xi⊕Yi ⊕Ci-1 C1=G1+P1C0 C2=G2+P2C1=G2+P2G1+P2P1C0 C3=G3+P3C2=G3+P3G2+P3P2G1+P3P2P1C0 C4=G4+P4C3=G4+P4G3+P4P3G2+P4P3P2G1+P4P3P2P1C0 4位全先行进位加 法器CLA （所有进位独立 并同时生成） 0: X,Y,C0 1: Pi,Gi 3: C1,2,3,4,Xi ⊕Yi 6: F1,2,3,4 4位CLU部件 局部（单级）先行进位加法器(不要求！)  Partial Carry Lookahead Adder • 实现全先行进位加法器的成本太高 • 位数多了，逻辑方程太长，电路面积大  折中做法： • 连接几个N位先行进位加法器，形成一个大加法器 • 例如：4个4位构成一个16位 4位先行进 位加法器 4位先行进 位加法器 4位先行进 位加法器 4位先行进 位加法器 C0C4C8C12C16 A16-13 B16-13 S16-13 A12-9 B12-9 S12-9 A8-5 B8-5 S8-5 A4-1 B4-1 S4-1 0 0 0 0 0 0 0 0 0 1 3 6 579 81012 1 1 1 “组内并行 组间串行” 多级先行进位加法器 • 通过引入组进位生成/传递函数实现 “组内并行、组间并行”进位方式 设n=4,则：C1=G0+P0C0 C2=G1+P1C1=G1+P1G0+P1P0C0 C3=G2+P2C2=G2+P2G1+P2P1G0+P2P1P0C0 C4=G3+P3C3=G3+P3G2+P3P2G1+P3P2P1G0+P3P2P1P0C0 Gm1 Pm1 所以C4 =Gm1+Pm1C0。类似的C8 =Gm2+Pm2C4等。然后与上述展开方法同理 ，C4,8,12,16只与C0和Pm、Gm有关。实现该逻辑的电路称为4位BCLA部件。 多级先行进位加法器 (不要求！) 在生成所有的P和G之后，需要2级门 延迟可计算出所有的Pm*和Gm* 然后还需要2级门延迟 计算出C4,8,12,16 C4 = Gm1 + Pm1 * C0 C8 = Gm2 + Pm2 * Gm1 + Pm2 * Pm1 *C0 C12 = Gm3 + Pm3 * Gm2 + Pm3 * Pm2 *Gm1 + Pm3* Pm2 * Pm1 * C0 C16 = Gm4 + Pm4 * Gm3 + Pm4 * Pm3*Gm2 + Pm4 * Pm3 * Pm2 * Gm1 + Pm4 * Pm3* Pm2 * Pm1 *C0 多级先行进位加法器 (不要求！) 4位成组先行进位部件（4位BCLA部件） 4位CLA 加法器 4位CLA 加法器 4位CLA 加法器 4位CLA 加法器 16位两级先行进位加法器 A BA BA BA B G P S G P S G P S G P S 最终进位 0: A,B,C0 1: Pi,Gi 3: Pmi,Gmi,C1,2,3 5: sum1,2,3, C4,C8,C12,C16 7: C5,6,7…… 10: sum其余位 C0 Pm1,Gm1Pm2,Gm2Pm3,Gm3Pm4,Gm4 C4C8C12C16 n位带标志加法器 • n位加法器无法用于两个n位带符号整数（ 补码）相加，无法判断是否溢出 • 程序中经常需要比较大小，通过（在加法器 中）做减法得到的标志信息来判断 溢出标志OF： OF=Cn⊕Cn-1 符号标志SF： SF=Fn-1 零标志ZF=1当且仅 当F=0； 进位/借位标志CF： CF=Cout⊕Cin （这里是串行进位）","libVersion":"0.2.4","langs":""}