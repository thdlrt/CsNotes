{"path":"归档课程/数字逻辑与计算机组成/课件/第6章 运算（2）ALU定点.pdf","text":"回顾第12次课  ROM和RAM  存储器  高级语言程序里的运算   ISA（例如：RISCV指令）   硬件功能部件  串行进位  先行进位  带标志的加法器 1 地 址 n m 存储 阵列 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 数据 16×8位 存储阵列 地 址 4 8 数据 4位的地址： 无符号数 8位的数据 ：机器数GPRs 0 1 2 3 ALU PC MAR MDR 标志寄存器 控制器 指令 数据 控制 地址 IR 存储器 0 1 2 3 14 15 OP addr 输入 设备 输出 设备 控制信号线 数据传送线 中央处理器（CPU） 现代计算机结构模型 F A B ALUop CPU：中央处理器；PC：程序计数器；MAR：存储器地址寄存器 ALU：算术逻辑部件；IR：指令寄存器；MDR：存储器数据寄存器 GPRs：通用寄存器组（由若干通用寄存器组成） 算术逻辑部件（ALU） • 有一个操作控制端（ALUop）， 用来决定ALU所执行的处理功能。 ALUop的位数k决定了操作的种类 例如，当位数k为3时，ALU最多 只有23=8种操作。 • 进行基本算术运算与逻辑运算 – 无符号整数加、减 – 带符号整数加、减 – 与、或、非、异或等逻辑运算 • 核心电路是整数加/减运算部件 • 输出除和/差等，还有标志信息 ALUop Result ALUop Result ALUop Result ALUop Result 0 0 0 A加B 0 1 0 A与B 1 0 0 A取反 1 1 0 A 0 0 1 A减B 0 1 1 A或B 1 0 1 A⊕B 1 1 1 未用 这里的唯 一结果怎 么得到？ 1-bit ALU和4-bit ALU（简化示意） 1-bit ALU A B FA CoutMux Cin F 4位ALU 实际的ALU中还包括减法、算术移位、逻辑移位等其他运算功能 ALUop 2 A1 B1 A2 B2 A3 B3 A4 B4 Cin Cout ALUop 2 F1 F2 F3 F4 串行进位 或者 先行进位 例：某ALU ALUop 第二讲：定点数运算 主 要 内 容  定点数加减运算 • 补码加减运算 • 原码加减运算 • 移码加减运算  定点数乘法运算 • 原码乘法运算 • 补码乘法运算 • 快速乘法器  定点数除法运算 • 原码除法运算 • 补码除法运算 n位整数加/减运算器 先看一个C程序段： int x=9, y=-6, z1, z2; z1=x+y; z2=x-y; 问题：上述程序段中，x和y的机器数是什么？z1和z2的机器数是 什么？ 回答：x的机器数为[x]补， y的机器数为[y]补 ; z1的机器数为[x+y]补 ; z2的机器数为[x-y]补 。 因此，计算机中需要有一个电路，能够实现以下功能： 已知 [x]补 和 [y]补 ，计算[x+y]补 和 [x-y]补 。 根据补码定义，有如下公式： [x+y]补 =2n+x+y= 2n+x+2n+y= [x]补+[y]补 (mod 2n ) [x-y]补=2n+x-y= 2n+x+2n-y= [x]补+[-y]补 (mod 2n ) 补码的定义 假定补码有n位，则： [X]补=2n +X （-2n≤X＜2n ,mod 2n） [–y]补=[y]补+1 n位整数加/减运算器 当Sub为1时，做减法 当Sub为0时，做加法 • 补码加减运算公式 [A+B]补 = [A]补 + [B] 补 ( mod 2n ) [A–B]补 = [A]补 + [–B] 补 ( mod 2n ) – 实现减法的主要工作在于：求 [–B]补=[B]补+1 Sum加法器 4 4 4 A ZF Cin Cout 4 B 4 0 1MUX Sub B OF 整数加/减运算部件 SF CF B＇ 注意：在整数加/减运算部件基础 上，加上寄存器、移位器以及控 制逻辑，就可实现ALU、乘/除运 算以及浮点运算电路 强调：带符号数、无符号数的加减法运算 SumAdder n n n A ZF Cin Cout n B n 0 1Mux Sel Sub B OF SF CF • 利用带标志加法器，可构造n位整数加/减运算部件，进行以下运算： 无符号整数加、无符号整数减 带符号整数加、带符号整数减 无符号数减法也用补码减法实现， 只是结果解释(标志位使用)不同 整数减法举例 -7- 6 = -7 + (-6) = +3 -3 - 5 = - 3 + (- 5) = - 8 9 - 6 = 9 + (-6) = 3 13 - 5 = 13 + (- 5) = 8 1 1+ + 0 0 0 1 1 1 1 0 0 1 1 10 1 111 0 0 0 1 0 0 0 11 11 带符号溢出判断： (1) 最高位和次高位的进位不同 或者 (2) 和的符号位和加数的符号位不同 X √ 做减法以比较大小，规则： Signed：OF=SF时，大于 OF=0、ZF=0、 SF=1、借位CF=0 OF=1、ZF=0 SF=0、借位CF=0 √√ 验证：-7<6，故OF≠SF -3<5，故OF≠SF 注意：Cin=sub=1 （Cout=1) （Cout=1) OF=Cn⊕Cn-1 CF=Cout⊕Cin Signed unsigned 无符号数减法例 9 - 6 = 3 4 - 7 = -3 1 1+ + 0 0 0 1 1 1 1 1 0 0 1 00 1 001 0 0 0 1 0 1 0 10 00 X 做减法以比较大小，规则： Unsigned: CF=0时，大于 OF=0、ZF=0、 SF=1、借位CF=1 OF=1、ZF=0 SF=0、借位CF=0 √ 验证：9>6，故CF=0； 13>5，故CF=0（见上页ppt） 无符号溢出判断：CF=1（减法时代表差为负数，即产生了借位） （加法时Cin=0，所以CF=1代表产生了进位，也就是加法溢出了） 注意：Cin=sub=1 （Cout=1) （Cout=0) OF=Cn⊕Cn-1 CF=Cout⊕Cin 验证：4< 7，故CF=1； 带(无)符号整数减法举例续 z1和k1的机器数一样：1001 0000，标志位也一样CF=1，OF=0，SF=1 无符号z1的真值为144(=134-246+256，x-y<0， CF=1，溢出) 带符号k1的真值为-112（=-122 – (-10) = -112， OF=0，正常） 假定 int为8位 unsigned int x=134; unsigned int y=246; int m=x; int n=y; unsigned int z1=x-y; unsigned int z2=x+y; int k1=m-n; int k2=m+n; 无符号减： 带符号减： + 1000 0110 + 0000 1001 + 0000 0001 + 1001 0000 x和m的机器数一样：1000 0110 y和n的机器数一样： 1111 0110 Cin=sub=1 Cout=0 （-122） （-10） 带(无)符号整数加法举例续 unsigned int x=134; unsigned int y=246; int m=x; int n=y; unsigned int z1=x-y; unsigned int z2=x+y; int k1=m-n; int k2=m+n; z2和k2的机器数一样：0111 1100，标志位也一样 CF=1，OF=1，SF=0 z2的值为124（=134+246-256，x+y>256， CF=1，溢出） k2的值为124（=-122+(-10)+256，m+n<-128， OF=1，负溢出） 假定 int为8位 无符号加公式： 带符号加公式： + 1000 0110 + 1111 0110 1 0111 1100 Cin=sub=0 Cout=1 x和m的机器数一样：1000 0110 y和n的机器数一样： 1111 0110 （-122） （-10） 例：实现部分MIPS指令的ALU 该ALU能实现哪些运算: add,sub,addu,subu,or,slt,sltu 能否实现定点乘除运算？ 能否实现浮点运算？ 不能！ 1(带符), less=OF⊕ SF 0(无符), less=Cin⊕Cout A | B B / B取反 减法时为1 A+B / A-B 0 / 1 无符号数的乘法运算  手算乘法示例: 被乘数 1000（X） 乘数 x 1001（Y-y1y2y3y4） 1000 0000 0000 1000 积 01001000 假定：[X]原=x0.x1…xn，[Y]原=y0.y1…yn ，求[x×Y]原 数值部分 z1…z2n = (x1…xn ) × ( y1…yn) (小数点位置约定，不区分小数还是整数) 两种操作：加法 + 移位 因而，可用ALU和移位器来实现乘法运算 0.1000× 0.1001 =2-1 ( 2-1 (2-1 (2-1 (0.1000× 1) + 1000× 0) + 1000× 0 ) + 1000× 1) 右移后，有效数字丢失了吗？ ——没有（预留存放的位置） 无符号乘法运算的算法推导  上述思想可写成如下数学推导过程： X×Y = X × ( 0.y1 y2… yn ) =2-1 ( 2-1 (2-1…2-1 (2-1 (0 + X× yn) + X× yn-1) +… + X× y2 ) + X× y1) n个2-1  递归!  无符号数乘法可归结为：设P0 = 0，每步的乘积为： P1 = 2-1 (P0+ X× yn) P2 = 2-1 (P1+ X× yn-1) …… …… Pn = 2-1 (Pn-1+ X× y1)  最终乘积Pn = X×Y (两个n位数相乘，得到2n位数） 迭代过程从乘数最低位yn和P0=0开始， 经n次“判断–加法–右移”循环，直到求出Pn为止。 4 X×Y= ∑ (X× yi×2-i) i=1 Example：无符号整数乘法运算 可用一个双倍字长的乘积寄存器； 也可用两个单倍字长的寄存器。 部分积初始为0。 保留进位位。 右移时进位、部分积和剩余乘数一 起进行逻辑右移。 验证：X=14, Y=13, XY=182 需要哪些存储空间？ 当乘积取低4位时，结果发生 溢出，因为高4位不为全0！ 举例说明： 设X=1110 Y=1101 应用递推公式： Pi=2-1(Xyi+ Pi-1) C 乘积P 乘数Y 0 0000 1101 + 1110 0 1110 1101 0 0111 0110 1 0 0011 1011 01 + 1110 1 0001 1011 01 0 1000 1101 101 + 1110 1 0110 1101 101 0 1011 0110 1101 回顾第13次课  算术逻辑部件（ALU）——核心是加法器，用ALUop指定运算类型  有（无）符号数的加减运算（溢出判断，大小比较）  无符号数乘法：“判断”、“加”+“右移”（每次逻辑右移1位） 写使能 控制逻辑 右移 32位 ALU 被乘数寄存器X 乘积寄存器P 32 64 位 32 32 32 加 计数器Cn 时钟 C 乘数寄存器Y 32位无符号乘法运算的硬件实现  被乘数寄存器X：存放被乘数  乘积寄存器P：开始置初始部分积P0 = 0；结束时，存放的是64位乘积的高32位  乘数寄存器Y：开始时置乘数；结束时，存放的是64位乘积的低32位  进位触发器C：保存加法器的进位信号  循环次数计数器Cn：存放循环次数。初值32，每循环一次，Cn减1，Cn=0时结束  ALU：乘法核心部件。在控制逻辑控制下，对P和X的内容“加”，在“写使能” 控制下运算结果被送回P，进位位在C中 每次循环都要对进位位C、乘积寄存器 P和乘数寄存器实现同步逻辑“右移” 原码乘法算法  用于浮点数尾数乘运算  符号与数值分开处理：积符异或得到，数值用无符号乘法运算 例：设[x]原=0.1110 ，[y]原=1.1101，计算 [x×y]原 解：数值部分用无符号数乘法算法计算：1110×1101= 1011 0110 符号位：0 ⊕ 1=1，所以： [x×y]原=1. 10110110 一位乘法：每次只取乘数的一位判断，需n次循环，速度慢。 两位乘法：每次取乘数两位判断，只需n/2次循环，快一倍。  两位乘法递推公式： 00：Pi+1=2-2Pi 01：Pi+1=2-2(Pi+X) 10：Pi+1=2-2(Pi+2X) 11：Pi+1=2-2(Pi+3X)=2-2(Pi+4X-X) =2-2(Pi-X)+X yi-1 yi T 操作（最后都要右移两位） 迭 代 公 式 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 0 → T +X 0 → T +X 0 → T +2X 0 → T +2X 0 → T –X 1 → T –X 1 → T 1 → T 2-2 (Pi ) 2-2 (Pi + X) 2-2 (Pi + X) 2-2 (Pi + 2X) 2-2 (Pi + 2X) 2-2 (Pi – X) 2-2 (Pi – X) 2-2 (Pi ) T触发器用来记录下次是否要执行“+X” “–X”运算用“+[-X]补”实现！ 3X时，本次-X，下次+X！ 原码两位乘法举例 已知 [X]原=0.111001， [Y]原= 0.100111，用原码两位乘法计算[X×Y]原 解： 先用无符号数乘法计算111001×100111，原码两位乘法过程如下： 有加有减，所 以要算术移位 若用模4补码， 中间涉及+2X 会导致P和Y同 时右移2位时， 得到的P3是负 数，就错了。 采用补码算术 右移，与一位 乘法不同？ 为什么用模8 补码形式(三 位符号位) ？ 速度快，但代价也大 若最后T=1， 则要+X 补码乘法运算 用于对什么类型的数据计算？已知什么？求什么？ 带符号整数！如C语句：int x=-5，y=-4，z=x*y; 因为[x*y]补≠ [x]补*[y]补 ，故不能直接用无符号整数乘法计算。 例如，若x=-5，求x*x=？： [-5]补=1011 [x*x]补： [25]补=0001 1001---正确 [x]补*[x]补；[-5]补* [-5]补=1111 1001---错误！ 问题：已知[x]补和[y]补，求[x*y]补 思路：根据[y]补求y，且[A+B]补= [A]补+[B]补 ， 只要将[x*y]补转换为对若干数的和求补即可 补码乘法运算Booth’s Algorithm推导 假定：[x]补=xn-1xn-2…… x1x0 ， [y]补=yn-1yn-2…… y1y0 ，求：[x*y]补=？ 基于补码求真值的公式： y=-yn-1.2n-1+yn-2 .2n-2+ …… y1 .21+ y0 .20 令：y-1 =0（不失正确性)，则： 当n=4时，y=-y3.23+y2 .22+ y1 .21+ y0.20 + y-1 .20 部分积公式：[Pi]补 = [ 2-1 ([Pi-1]补+ (yi-1-yi) · x) ]补 不失正确性—— 2-4.[x*y]补=【 (y2 –y3 ) .x.2-1+(y1-y2) .x.2-2+ (y0–y1) .x.2-3 +(y-1-y0) .x.2-4】补 = 【 2-1(2-1(2-1 (2-1(y-1-y0) .x) + (y0–y1) .x) + (y1 –y2) .x) + (y2 –y3) .x) 】补 符号与数值统一处理 = -y3 .23+(y2 .23-y2 .22) +(y1 .22-y1 .21) +(y0 .21-y0 .20)+ y-1 .20 = (y2 –y3 ).23 + (y1-y2).22 + (y0–y1).21 + (y-1-y0).20 即：[Pi-1]补+ [±x] 补后右移一位（算术右移） 注意：这里的yi就是补 码中的某一位！ Booth’s 算法实质  y当前位yi y右边位yi-1 操作 Example 1 0 减被乘数x 0001111000 1 1 加0 (不操作) 0001111000 0 1 加被乘数x 0001111000 0 0 加0 (不操作) 0001111000  在“1串”中，第一个1时做减法，最后一个1做加法，其余情况只要移位。  最初提出这种想法是因为在Booth的机器上移位操作比加法更快！ 同前面算法一样，将乘积寄存器右移一位。（这里是算术右移） 0 1 1 1 1 0 beginning of runend of run middle of run 右移只是把位置空出来，最终从n位变为2n位空间， 小数点位置依然默认是在最左边的，所以并非是把真值缩小 布斯算法举例 已知[X]补 = 1 101，[Y]补 = 0 110，计算[X×Y]补 验证：当X×Y取8位时，结果 -0010010B=-18；取低4位时，结果溢出 [-X]补 = 0011 1 1 1 1 X=-3，Y=6，X×Y=-18，[X×Y]补应等于11101110或结果溢出 如何判断结 果是否溢出？ 高4位是否全 为符号位！ 如果X是-8， 那么 [-X]补就溢出了?：除了移位实 现（快），也可以P前面加补充符号位 （慢）补码两位乘法  补码两位乘可用布斯算法推导如下： • [Pi+1]补 = 2-1 ( [Pi]补 + ( yi-1– yi ) [X]补) • [Pi+2]补 = 2-1 ( [Pi+1]补 + ( yi – yi+1) [X]补) = 2-1 (2-1 ( [Pi]补 + ( yi-1– yi ) [X]补) + ( yi – yi+1) [X]补) = 2-2 ( [Pi]补+ (yi-1 + yi – 2yi+1) [X]补)  开始置附加位y-1为0，乘积寄 存器最高位前面添加一位附加 符号位0。  最终的乘积高位部分在乘积寄 存器P中，低位部分在乘数寄 存器Y中。  因为字长总是8的倍数，所以 补码的位数n应该是偶数，因 此，总循环次数为n/2。 yi+1 yi yi-1 操作(都要 右移两位) 迭 代 公 式 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 0 +[X]补 +[X]补 +2[X]补 +2[-X] 补 +[-X]补 +[-X]补 0 2-2[Pi]补 2-2{[Pi]补+[X]补} 2-2{[Pi]补+[X]补} 2-2{[Pi]补+2[X]补} 2-2{[Pi]补+2[-X]补 } 2-2{[Pi]补+[-X]补} 2-2{[Pi]补+[-X]补} 2-2[Pi]补 补码两位乘法举例  已知 [X]补 = 1 101， [Y]补 = 0 110，用补码两位乘法计算[X×Y]补。  解：[–X]补= 0 011，用补码二位乘法计算[X×Y]补的过程如下。 Pn P Y y-1 说明 0 0 0 0 0 0 1 1 0 0 开始，设y-1 = 0，[P0]补 = 0 + 0 0 1 1 0 y1y0y-1 =100，+2[-X]补 0 0 1 1 0 P和Y同时右移二位 0 0 0 0 1 1 0 0 1 1 得[P2]补 + 1 1 0 1 0 y3y2y1 = 011，+2[X]补 1 1 0 1 1 P和Y同时右移二位 1 1 1 1 0 1 1 1 0 得[P4]补 因此 [X×Y]补=1110 1110 ，与一位补码乘法（布斯乘法）所得结果相 同，但循环次数减少了一半。 验证：-3×6=-18 （-10010B） 2 2 快速乘法器（不要求）  前面介绍的乘法部件的特点 • 通过一个ALU多次做“加/减+右移”来实现 - 一位乘法：约n次“加+右移” - 两位乘法：约n/2次“加+右移” 所需时间随位数增多而加长，由时钟和控制电路控制  设计快速乘法部件的必要性 • 大约1/3是乘法运算  快速乘法器的实现（由特定功能的组合逻辑单元构成） • 流水线方式 • 硬件叠加方式（如：阵列乘法器）  为乘数的每位提供一个n位加法器  每个加法器的两个输入端分别是： • 本次乘数对应的位与被乘数相与的 结果（即：0或被乘数） • 上次部分积  每个加法器的输出分为两部分： • 和的最低有效位(LSB)作为本位乘积 • 进位和高31位的和数组成一个32位数 作为本次部分积 流水线快速乘法器（不要求） 部分积0或被乘数A 进位+31位+1位 像流水一样，完全是串行，浪费 加法器资源——但是，组合逻辑 电路！无需控制器控制 CRA阵列乘法器（不要求）  阵列乘法器：“细胞”模块的阵列 全加器 部分积 1位输入 Ai Bi 进位 输入 进位输出 部分积 1位输出 被乘数X B0 0 P7 P6 P5 P4 P3 P2 P1 P0 B1 0 B2 0 B3 0 A3 A2 A1 A0 0 0 0 0 速度仅取决 于逻辑门和 加法器的传 输延迟 无符号阵列乘法器 增加符号处理电路 、乘前及乘后求补 电路，即可实现带 符号数乘法器。 手工 计算 Ai Bi 还可采用树形结构（如华莱士树）进行部分积求和，以加快速度 归纳：整数的乘运算 可用无符号乘来实现带符号乘。 n位 x n位，结果机器数可获得高n位和低n位。 高n位可用来判断溢出，也可直接作为乘积的高位（肯定不溢出）。 带符号乘法器 Xs Ys Ps n n n n Psh 小写字母都是真值(下页ppt)，大写字母都是机器数 u代表unsigned，s代表signed Puh Psh≠ Pu Ps= 不一定等于 低位高位 无符号乘法器 Xu Yu Pu n n n n Puh 低位高位 如果： Xu=Xs Yu=Ys 则： 补码 整数的乘运算（溢出判断）  如果结果仅保留低n位， X*Y的高n位可以用来判断溢出，规则如下： • 无符号：若高n位全0，则不溢出，否则溢出 • 带符号：若高n位全0或全1且等于低n位的最高位，则不溢出。 整数的乘运算（机器级语言层面）  机器指令：分无符号数乘指令、带符号整数乘指令  硬件可保留2n位乘积，故有些指令的乘积为2n位，可供软件使用  乘法指令的操作数长度为n, 而乘积长度为2n，例如： • IA-32中，若指令只给出一个操作数SRC，则另一个源操作数隐含在 累加器AL/AX/EAX中，将SRC和累加器内容相乘，结果存放在AX（ 16位时）或DX-AX（32位时）或EDX-EAX（64位时）中。 • MIPS中，mult会将两个32位带符号整数相乘，得到的64位乘积置 于两个32位内部寄存器Hi和Lo中，因此，可以根据Hi寄存器中的每 一位是否等于Lo寄存器中的第一位来进行溢出判断。 • RISC-V中，用“mul rd, rs1, rs2”获得低32位乘积并存入结果寄存 器rd中；mulh、mulhu指令分别将两个乘数同时按带符号整数、同 时按无符号整数相乘后，得到的高32位乘积存入rd中 乘法指令可生成溢出标志，编译器可使用2n位乘积来判断是否溢出！ 高级语言程序也可以增加防止溢出的代码。（如果都不做，可能出严重错误） ——乘法指令的硬件实现时就进行溢出判 断和标志生成 ——编译后生成的指令序列： 指令1：mul r1, rs1, rs2 指令2：mulh r2, rs1, rs2 指令3。。。：判断r1和r2的内容情况 指令x：如果溢出就跳转。。 整数的乘运算（高级语言程序层面） 在计算机内部，一定有x2 ≥ 0吗? 若x是带符号整数，则不一定！ 如x是浮点数，则一定！ 例如，当 n=4 时, 52=-7<0 ! 0101 0101 0101 0101 × + 00011001 只取低4位，值为-111B=-7 结果 溢出 注意：这里是针对【n位 与 n位相乘，结果保留n位】的情况。 int imul_overflow(int x, int y) {//判断是否溢出 return x*y/y !=x } 多进行一次除法运算， 程序变慢！ 思考（自学） 在字长为32位的计算机上，某C函数原型声明为： int imul_overflow(int x, int y); 该函数用于对两个int型变量x和y的乘积（也是int类型）判断是否溢出，若 溢出则返回非0，否则返回0。请完成下列任务或回答下列问题。 （1）两个n位无符号数（带符号整数）相乘的溢出判断规则各是什么？ 无符号整数相乘：若乘积的高n位为非0，则溢出。 带符号整数相乘：若乘积高n位的每一位都相同，且都等于乘积低n 位的符号，则不溢出，否则溢出。 （2）已知入口参数x、y分别在寄存器a0、a1中，返回值在a0中，写出实现 imul_overflow函数功能的RISC-V汇编指令序列，并给出注解。（编 译器中判断溢出的代码，学完第7章再做） （3）使用64位整型（long long）变量来编写imul_overflow函数的C代码 或描述实现思想。 思考（自学） （2）RISC-V汇编指令序列 实现该功能的汇编指令序列不唯一。 某实现方案下的汇编指令序列如下： mul t0, a0, a1 # x*y的低32位在t0中 mulh a0, a0, a1 # x*y的高32位在a0中 srai t0, t0, 31 # 乘积的低32位算术右移31位 xor a0, a0, t0 # 按位异或，若结果为0，表示不溢出 思考（自学） （3）采用long long型变量实现的C程序 将x*y的结果保存在long long型变量中，得到64位乘积，然后 把64位乘积强制转换为32位，再符号扩展成64位，和原来真正 的64位乘积相比，若不相等则溢出。 int imul_overflow(int x, int y) { long long prod_64= (long long) x*y; return prod_64 != (int) prod_64; } 例如：x=-4,y=6, 位数n=4 则prod_8=1110 1000 截断后为1000 重新扩展为1111 1000","libVersion":"0.2.4","langs":""}