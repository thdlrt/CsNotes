{"path":"docs/课程/编译原理/课件/Chapter_3.pdf","text":"许畅 南京大学计算机系 2024年春季 第三章 词法分析 版权所有 南京大学计算机科学与技术系 许畅 2024春季版 内容 • 词法分析器的作用 • 词法单元的规约 (正则表达式) • 词法单元的识别 (状态转换图) • 词法分析器生成工具及设计 • 有穷自动机 2 词法分析器的作用 • 读入字符流，组成词素，输出词法单元序列 • 过滤空白、换行、制表符、注释等 • 将词素添加到符号表中 • 在逻辑上独立于语法分析，但是通常和语法分析 器处于同一趟中 3 为什么要设立独立的词法分析器？ • 简化编译器的设计 – 词法分析器可以首先完成一些简单的处理工作 • 提高编译器效率 – 相对于语法分析，词法分析过程简单，可高效实现 (下 推自动机 vs. 有穷自动机) • 增强编译器的可移植性 4 词法单元、模式、词素 • 词法单元 (token) – <词法单元名、属性值 (可选) > – 单元名是表示词法单位种类的抽象符号，语法分析器 通过单元名即可确定词法单元序列的结构 – 属性值通常用于语义分析之后的阶段 • 模式 (pattern) – 描述了一类词法单元的词素可能具有的形式 • 词素 (lexeme) – 源程序中的字符序列 – 它和某个词法单元的模式匹配，被词法分析器识别为 该词法单元的实例 5 词法单元、模式、词素 (例子) • printf(\"Total = %d\\n\", score)； – printf和score与标识符 (id) 的模式匹配 – \"Total = %d\\n\"与literal的模式匹配 6 词法单元的属性 • 一个模式匹配多个词素时，必须通过属性来传递 附加的信息 – 属性值将被用于语义分析、代码生成等阶段 • 不同的目的需要不同的属性 – 属性值通常是一个结构化数据 • 如词法单元id的属性 – 词素、类型、第一次出现的位置、… 7 内容 • 词法分析器的作用 • 词法单元的规约 (正则表达式) • 词法单元的识别 (状态转换图) • 词法分析器生成工具及设计 • 有穷自动机 8 词法单元的规约 • 正则表达式可以高效、简洁地描述处理词法单元 时用到的模式类型 • 内容 – 串和语言 – 语言上的运算 – 正则表达式和正则定义 – 正则表达式的扩展 9 串和语言 (1) • 字母表 (alphabet) ：一个有穷的符号集合 – 符号典型例子：字母、数字、标点符号 – 例子：{ 0, 1 }, ASCII, Unicode – 在理论上，我们可以把任意的有限集合看作字母表 • 字母表上的串 (string) 是该表中符号的有穷序列 – 串s的长度，即 |s|，是指s中符号出现的次数 – 空串：长度为0的串，ε • 语言 (language) 是某个给定字母表上的串的可数 集合 10 串和语言 (2) • 和串有关的术语 (以banana为例) – 前缀 (prefix)：从串的尾部删除0个或多个符号后得到 的串 (ban、banana、ε) – 后缀 (suffix)：从串的开始处删除0个或多个符号后得 到的串 (nana、banana、ε) – 子串 (substring)：删除串的某个前缀和某个后缀得到 的串 (banana、nan、ε) – 真前缀、真后缀、真子串：既不等于原串，也不等于 空串的前缀、后缀、子串 (前面例子的红色部分) – 子序列：从原串中删除0个或者多个符号后得到的串 (baan) 11 串和语言 (3) • 串的运算 – 连接 (concatenation)：x和y的连接是把y附加到x的后 面而形成的串，记作xy • x = dog，y = house，xy = doghouse – 指数运算：s0 = ε，s1 = s，si = si-1s • x = dog，x0 = ε，x1 = dog，x3 = dogdogdog 12 串和语言 (4) • 语言的运算 – 语言是某个给定字母表上的串的可数集合 13 + 串和语言 (5) • 例子 – L = { A, B , ……, Z, a, b, ……, z } – D = { 0, 1, ……, 9 } – L  D = { A, B, ……, Z, a, b, ……, z, 0, 1, ……, 9 } – LD：520个长度为2的串的集合 (字母 + 数字) – L4：所有由四个字母构成的串的集合 – L*：所有字母构成的集合，包括ε – L (L  D)*：？ – D+：？ 14 正则表达式 • 字母表Σ上的正则表达式的定义 – 基本部分 • ε是一个正则表达式，L(ε) = { ε } • 如果a是Σ上的一个符号，那么a是正则表达式，L(a) = { a } – 归纳步骤 • 选择：(r)|(s)，L((r)|(s)) = L(r)  L(s) • 连接：(r)(s)，L((r)(s)) = L(r)L(s) • 闭包：(r)*，L((r)*) = (L(r))* • 括号：(r)，L((r)) = L(r) • 运算的优先级：* > 连接 > |，如(a) | ((b)*(c)) = a | b*c • 正则集合 (regular set)：可用一个正则表达式定义的语言 15 例子 • Σ = { a, b } • L(a | b) = { a, b } • L((a | b) (a | b)) = { aa, ab, ba, bb } • L(a*) = { ε, a, aa, aaa, aaaa, … } • L((a | b)*) = { ε, a, b, aa, ab, ba, bb, aaa, aab, … } • L(a | a*b) = { a, b, ab, aab, aaab, … } 16 正则表达式的等价 • 如果L(r) = L(s)，正则表达式r和s等价 (equivalent) 17 正则定义 (1) • 为了书写方便，可以给正则表达式命名 • 正则定义 (regular definition) 是如下的定义序列： d1 → r1 d2 → r2 … dn → rn • 其中 – di不在Σ中，且各不相同 – 每个ri是字母表Σ  { d1, d2, …, di-1 }上的正则表达式； 这保证了不会出现递归定义 18 正则定义 (2) • 各个di的Σ上的正则表达式如下 – d1的正则表达式即r1 – 将r2中的d1替换为r1，得到d2的正则表达式 – … – 将ri中的d1, d2, …, di-1替换为各自的正则表达式，得到di 的正则表达式 19 例子 • C语言标识符的正则定义 – letter_ → A | B | … | Z | a | b | … | z | _ – digit → 0 | 1 | … | 9 – id → letter_ ( letter_ | digit )* • id对应的正则表达式为 – (A | B | … | Z | a | b | … | z | _) ( (A | B | … | Z | a | b | … | z | _) | (0 | 1 | … | 9) )* 20 正则表达式的扩展 • 基本运算符：选择、连接、Kleene闭包 • 扩展的运算符 – 一个或多个实例：单目后缀+ • r+等价于r r* – 零个或一个实例：？ • r?等价于ε | r – 字符类 • [a1a2…an]等价于a1 | a2 | … | an • 使用−符号，如：[a−e]等价于a | b | c | d | e • 使正则表达式更简洁，但不会使其描述能力增强 21 内容 • 词法分析器的作用 • 词法单元的规约 (正则表达式) • 词法单元的识别 (状态转换图) • 词法分析器生成工具及设计 • 有穷自动机 22 词法单元的识别 • 词法分析器要求能够检查输入字符串，在其前缀 中找出和某个模式匹配的词素 • 首先通过正则定义来描述各种词法单元的模式 • 定义ws → (blank | tab | newline)+来消除空白 – 当词法分析器识别出这个模式时，不返回词法单元， 继续识别其它模式 2324 状态转换图 • 词法分析器的重要组件之一 • 状态转换图 (transition diagram) – 状态 (state)：表示在识别词素时可能出现的情况 • 状态看作是已处理部分的总结 • 某些状态为接受状态或最终状态，表明已找到词素 • 加上*的接受状态表示最后读入的符号不在词素中 • 开始状态 (初始状态)：用Start边表示 – 边 (edge)：从一个状态指向另一个状态 • 边的标号是一个或多个符号 • 当前状态为s，下一个输入符号为a，就沿着从s离开，标号为a 的边到达下一个状态 25 例子 26 保留字和标识符的识别 • 在很多时候，保留字也符合标识符的模式 – 识别标识符的状态转换图也会识别保留字 • 解决方法 – 在符号表中先填保留字，并指明它们不是普通标识符 – 为保留字建立独立的、高优先级的状态转换图 27 其它的状态转换图 28 词法分析器的体系结构 • 从转换图构造词法分析器的方法 – 变量state记录当前状态 – 一个switch语句根据state的值转到相应的代码 – 每个状态对应于一段代码 • 这段代码根据读入的符号，确定下一个状态 • 如果找不到相应的边，则调用fail()进行错误恢复 – 进入某个接受状态时，返回相应的词法单元 • 注意状态有*标记时，需要回退forward指针 • 实际是模拟转换图的运行 2930 relop对应的代码概要处理多个模式的方法 • 词法分析器需要匹配多个模式 • 解决方法 – 按照优先级，顺序地尝试各个状态转换图，如果引发 fail()，回退并尝试下一个状态图 – 更好的方法：并行地运行各个状态转换图；通过 greedy策略，识别最长的与某个模式匹配的输入前缀 – 实际使用的方法：预先把各个状态转换图合成一个状 态转换图，然后运行这个状态转换图 (后面介绍) 31 内容 • 词法分析器的作用 • 词法单元的规约 (正则表达式) • 词法单元的识别 (状态转换图) • 词法分析器生成工具及设计 • 有穷自动机 32 词法分析工具Lex • Lex/Flex是一个有用的词法分析器生成工具 • 通常和Yacc一起使用，生成编译器的前端 33 Lex源程序的结构 • 声明部分 – 常量：表示常数的标识符 – 正则定义 • 转换规则 – 模式 { 动作 } • 模式是正则表达式 • 动作表示识别到相应模式时应采取的处理方式 • 处理方式通常用是C语言代码表示 • 辅助函数 – 各个动作中使用的函数 34 声明部分 %% 转换规则 %% 辅助函数 Lex程序的形式 例子 (1) 35 %{和}%之间的内容一般被 直接拷贝到lex.yy.c中； 这里的内容就是一段注释； LT、LE等的值在Yacc源程 序中定义 正则定义 分隔声明部分和 转换规则部分 例子 (2) 36 没有返回，表示 继续识别其它的 词法单元 把识别到的标识符 加入标识符表 识别到数字常量， 加入常量表 例子 (3) • Lex处理源程序时，辅助函数被拷贝到lex.yy.c中 • 辅助函数可在规则中直接调用 37 词法分析器的工作方式 • Lex生成的词法分析器作为一个函数被调用 • 在每次调用过程中，不断读入余下的输入符号 • 发现最长的、与某个模式匹配的输入前缀时 – 调用相应的动作，该动作进行相关处理 – 之后词法分析器继续寻找其它词素 39 Lex中的冲突解决方法 • 冲突：多个输入前缀与某个模式相匹配，或者一 个前缀与多个模式相匹配 • Lex解决冲突的方法 – 多个前缀可能匹配时，选择最长的前缀 • 比如，词法分析器把<=当作一个词法单元识别 – 最长的前缀与多个模式匹配时，选择列在前面的模式 • 如果保留字的规则在标识符的规则之前，词法分析器将识别出 保留字 40 内容 • 词法分析器的作用 • 词法单元的规约 (正则表达式) • 词法单元的识别 (状态转换图) • 词法分析器生成工具及设计 • 有穷自动机 41 有穷自动机 • 本质上和状态转换图相同，但有穷自动机 (finite automata) 只回答Yes/No – 分为两类 • 不确定的有穷自动机 (Nondeterministic Finite Automata / NFA)：边上的标号没有限制，一个符号可出现在离开同一个 状态的多条边上， ε可以做标号 • 确定的有穷自动机 (Deterministic Finite Automata / DFA)： 对于每个状态以及每个符号，有且只有一条边 (或最多只有一 条边) • 两种自动机都识别正则语言 (regular language) – 对于每个可以用正则表达式描述的语言，均可用某个 NFA或DFA来识别；反之亦然 42 不确定的有穷自动机 • NFA的定义 – 一个有穷的状态集合S – 一个输入符号集合Σ，即输入字母表 (input alphabet) – 转换函数 (transition function) 对于每个状态和Σ  {ε} 中的符号，给出相应的后继状态 (next state) 集合 – S中的某个状态s0被指定为开始状态/初始状态 (有些定 义中可以有多个开始状态) – S的一个子集F被指定为接受状态集合 43 NFA的例子 • 状态集合S = { 0, 1, 2, 3 } • 开始状态s0：0 • 接受状态集合F：{ 3 } • 转换函数 – (0, a) → { 0, 1 } (0, b) → { 0 } – (1, b) → { 2 } (2, b) → { 3 } 44 相应的图形表示 转换表 (transition table) 表示法 • 用二维表表示NFA的转换函数 – 每行对应于一个状态 – 每列对应于一个输入符号或者ε – 每个条目表示对应的后继状态集合 45 转换表表示法 输入字符串的接受 • 一个NFA接受 (accept) 输入字符串x – 当且仅当对应的转换图中存在一条从开始状态到某个 接受状态的路径，且该路径各条边上的标号按顺序组 成x (不含ε标号) • 前面的NFA接受aabb，因为 • NFA接受的语言：从开始状态到达接受状态的所 有路径的标号串的集合 – 即该NFA接受的所有符号串的集合 46 NFA和相应语言的例子 • 相应的语言：L(aa* | bb*) 47 确定的有穷自动机 • 一个NFA被称为DFA，如果 – 没有标号为ε的转换，并且 – 对于每个状态s和每个输入符号a，有且仅有一条标号为 a的离开s的边 • 可以高效判断一个串能否被一个DFA接受 • 每个NFA都有一个等价的DFA (后面介绍) – 即它们接受相同的语言 48 DFA的模拟运行 • 假设输入符号是字符 • nextChar读入下一个字符 • move给出了离开状态s且标号为c的边的目标状态 49 DFA的例子 • 假设输入为ababb，那么进入的状态序列为 – 0, 1, 2, 1, 2, 3，返回yes 50 从正则表达式到自动机的转换 • 正则表达式可简洁、精确地描述词法单元的模式 • 模拟DFA的执行可高效地进行模式匹配 • 将正则表达式转换为DFA的步骤 – 正则表达式到NFA – NFA到DFA 51 NFA到DFA (1) • 子集构造法 (subset construction) 的基本思想 – 构造得到的DFA的每个状态和NFA的状态子集对应 – DFA读入a1, a2, …, an后到达的状态对应于从NFA开始 状态出发沿着a1, a2, …, an可能到达的状态集合 – 在算法中“并行地模拟”NFA在遇到一个给定输入串 时可能执行的所有动作 52 例子 (1) • 下面的NFA能够接受串babb – 考虑从开始状态出发，沿着标号分别为b，ba，bab， babb能到达的所有可能状态的集合 53 NFA到DFA (2) • 理论上，最坏情况下DFA的状态个数会是NFA状 态个数的指数多个 – 但对于大部分应用，NFA和相应的DFA的状态数量大 致相同 54 NFA到DFA (3) • 算法中使用到的基本操作 – ε–closure(s)：从NFA状态s开始，只通过ε转换能到达 的NFA状态集合 – ε–closure(T)：从T中某个状态s开始，只通过ε转换能 到达的NFA状态集合 – move(T, a)：从T中某个状态s出发，通过一个标号为a 的转换能到达的NFA状态集合 55 NFA到DFA (4) • 计算ε–closure(T)的算法 – 实际上是一个图搜索过程 (只考虑ε标号边) 56 NFA到DFA (5) • 整个算法实际是一个搜索过程 – Dstates中的一个状态未加标记表示还没有搜索过它的 各个后继 57 例子 (2) A: ε–closure(0) = { 0, 1, 2, 4, 7 } B: Dtran[A, a] = ε–closure({ 3, 8 }) = { 1, 2, 3, 4, 6, 7, 8 } C: Dtran[A, b] = ε–closure({ 5 }) = { 1, 2, 4, 5, 6, 7 } D: Dtran[B, b] = ε–closure({ 5, 9 }) = { 1, 2, 4, 5, 6, 7, 9 } … 58 例子 (3) • 开始状态：A；接受状态：E 59 正则表达式到NFA • 基本思想 – 根据正则表达式的递归定义，按照正则表达式的结构 递归地构造出相应的NFA – 算法分成两个部分 • 基本规则处理ε和单符号的情况 • 对于每个正则表达式的运算，建立组合相应NFA的方法 60 转换算法 (1) • 基本规则部分 – 表达式ε – 表达式a 61 转换算法 (2) • 归纳部分 – s | t – st 62 转换算法 (3) • 归纳部分 – s* 63 例子 (1) • 正则表达式：(a|b)*abb • 第一个a对应的NFA • 第一个b对应的NFA 64 例子 (2) • (a|b)的NFA 65 例子 (3) • (a|b)*的NFA 66 词法分析器生成工具的功能 • 生成的词法分析器中包含一个模拟有穷自动机的 模块 • 其余部分由生成工具根据词法规则的描述自动生 成，包括 – 自动机的转换表 – 与动作相关的代码，适当的时候由模拟器调用 • 构造自动机时 – 首先构造出各个模式对应的NFA – 然后将这些NFA合并成为一个NFA – (根据需要) 进行确定化 (DFA) 68 NFA合并的方法 • 合并方法 – 引入新的开始状态，并引入从该开始状态到各个原开 始状态的ε转换 – 得到的NFA所接受的语言是原来各个NFA语言的并集 – 不同的接受状态代表不同的模式 69 确定化NFA后的处理 • 对得到的NFA进行确定化，得到DFA • 一个DFA的接受状态对应于NFA的状态子集，其 中至少包括一个NFA的接受状态 – 如果其中包括多个对应于不同模式的NFA接受状态， 则表示当前的输入前缀对应于多个模式，存在冲突 – 找出第一个这样的模式，将该模式作为此DFA接受状 态的输出 70 例子 (1) • 假设有三个模式 – a {A1} – abb {A2} – a*b+ {A3} • 构造各模式的NFA 71 例子 (2) • 合并NFA – 2：模式1 – 6：模式2 – 8：模式3 72 模式1 模式2 模式3 例子 (3) • 确定化得到如下DFA – DFA状态68对应的NFA状态子集为{ 6, 8 }，其对应的 模式是abb (即模式2)，而不是a*b+ (即模式3) 73 模式3 模式3 模式1 模式2/3 ? DFA状态数量的最小化 • 一个正则语言可对应于多个识别此语言的DFA • 通过DFA的最小化可得到状态数量最少的DFA (不计同构，这样的DFA是唯一的) 74 两个等价的DFA：都识别 (a|b)*abb 状态的区分 • 状态的可区分 (distinguishable) – 如果存在串x，使得从状态s1和s2，一个到达接受状态 而另一个到达非接受状态，那么x就区分了s1和s2 – 如果存在某个串区分了s和t，我们说s和t是可区分的， 否则它们是不可区分的 • 不可区分的两个状态就是等价的，可以合并 75 空串区分了E和其它状态； bb区分了A和B DFA最小化算法 • 把所有可区分的状态分开 (迭代过程) – 基本步骤：ε区分了接受状态和非接受状态 – 归纳步骤：如果s和t是可区分的，且s'到s、t'到t有标号 为a的边，那么s'和t'也是可区分的 • 最终没有区分开的状态就是等价的 – 所有的死状态都是等价的 • 从划分得到的等价类中选取代表，并重建DFA 76 最小化算法 (划分部分) • 设置初始划分：П = { S − F, F } • 迭代，不断划分 for (П中的每个元素G) { 细分G，使得G中的s、t仍然在同一组中 iff 对任意输入a，s、t都到达П中的同一组； Пnew = 将П中的G替换为细分得到的小组 } • 如果Пnew == П，令Пfinal = П，算法完成；否则П = Пnew，转步骤2 77 最小化算法 (构造部分) • 在Пfinal的每个组中选择一个状态作代表，作为最 小化DFA中的状态 – 开始状态就是包含原开始状态的组的代表 – 接受状态就是包含了原接受状态的组的代表 (这个组一 定只包含接受状态) – 转换关系构造如下 • 如果s是G的代表，而原DFA中s在a上的转换到达t，且t所在组 的代表为r，那么最小化DFA中有从s到r的在a上的转换 78 DFA最小化的例子 • 初始划分：{ { A, B, C, D }, { E } } • 处理{ A, B, C, D }：b把它细分为{ A, B, C }和{ D } • 处理{ A, B, C }：b把它细分为{ A, C }和{ B } • 选取A, B, D和E为代表，构造得到最小DFA 79 词法分析器状态的最小化 • 基本思想和DFA最小化算法相同 • 差别 – 词法分析器中的接受状态对应于不同的模式 – 对应不同模式的接受状态一定是不等价的 – 初始划分为 • 所有非接受状态集合 + 对应各模式的接受状态集合 • 其余划分和构造的方法均相同 • 接受状态对应的模式就是原来的模式 80 例子 ◼ 初始划分：{0137, 7}, {247}, {68}, {8, 58}, {Φ} – 增加死状态Φ 81 模式3 模式3 模式1 模式2","libVersion":"0.2.4","langs":""}