{"path":"归档课程/数据结构/课件/数组、串、广义表.pdf","text":"第四章 数组、串与广义表 • 一维数组与多维数组 • 特殊矩阵 • 稀疏矩阵 • 字符串 • 广义表 1 一维数组 • 定义 数组是相同类型的数据元素的集合，而一维 数组的每个数组元素是一个序对，由下标 （index）和值（value）组成。 • 一维数组的示例 • 在高级语言中的一维数组只能按元素的下标 直接存取数组元素的值。 35 27 49 18 60 54 77 83 41 02 0 1 2 3 4 5 6 7 8 9 2 一维数组的定义和初始化 #include <iostream.h> void main ( ) { int a[3] = { 3, 5, 7 }, *elem, i; //静态数组 for (i = 0; i < 3; i++) cout << a[i] << endl; elem = new int[3]; //动态数组 for (i = 0; i < 3; i++) cin >> elem[i]; int * temp = elem; for (i = 0; i < 3; i++) { cout << *temp<< endl; temp++; } delete [] elem; } 3 多维数组 • 多维数组是一维数组的推广。 • 多维数组的特点是每一个数据元素可以有多 个直接前驱和多个直接后继。 • 数组元素的下标一般具有固定的下界和上界， 因此它比其他复杂的非线性结构简单。 • 例如二维数组的数组元素有两个直接前驱， 两个直接后继，必须有两个下标（行、列） 以标识该元素的位置。 4 二维数组 三维数组 行向量 下标 i 页向量 下标 i 列向量 下标 j 行向量 下标 j 列向量 下标 k 5 数组的连续存储方式 一维数组 LOC(i) = LOC(i-1)+l = a+i*l, i > 0 a, i = 0 35 27 49 18 60 54 77 83 41 02 0 1 2 3 4 5 6 7 8 9 l l l l l l l l l l a+i*l a 6 二维数组 • 一维数组常被称为向量（Vector）。 • 二维数组 A[m][n] 可看成是由 m 个行向量 组成的向量，也可看成是由 n 个列向量组成 的向量。 • 一个二维数组类型可以定义为其分量类型为 一维数组类型的一维数组类型: typedef T array2[m][n]; //T为元素类型 等价于： typedef T array1[n]; //列向量类型 typedef array1 array2[m]; //二维数组类型 7 • 同理，一个三维数组类型可以定义为其数据 元素为二维数组类型的一维数组类型。 • 静态定义的数组，其维数和维界不再改变， 在编译时静态分配存储空间。一旦数组空间 用完则不能扩充。 • 动态定义的数组，其维界不在说明语句中显 式定义，而是在程序运行中创建数组对象时 通过 new 动态分配和初始化，在对象销毁 时通过 delete 动态释放。 • 用一维内存来表示多维数组，就必须按某种 次序将数组元素排列到一个序列中。 8 二维数组的动态定义和初始化 #include <iostream.h> ………… int **A; int row = 3, col = 3; int i, j; A = new int *[row]; for (i = 0; i < row; i++) A[i] = new int [col]; for (i = 0; i < row; i++) for (j = 0; j < col; j++) cin >> A[i][j]; ………… 9 二维数组中数组元素的顺序存放  行优先存放： 设数组开始存放位置 LOC(0, 0) = a, 每个 元素占用 l 个存储单元  LOC ( j, k ) = a + ( j * m + k ) * l 10 列优先存放： 设数组开始存放位置 LOC(0, 0) = a, 每个 元素占用 l 个存储单元 LOC ( j, k ) = a + ( k * n + j ) * l 11 三维数组 • 各维元素个数为 m1, m2, m3 • 下标为 i1, i2, i3的数组元素的存储地址： （按页／行／列存放） LOC ( i1, i2, i3 ) = a + ( i1* m2 * m3 + i2* m3 + i3 ) * l 前i1页 总元素 个数 第i1页 前i2行 总元素 个数 第 i2 行 前 i3 列 元素个 数 12 n 维数组 • 各维元素个数为 m1, m2, m3, …, mn • 下标为 i1, i2, i3, …, in 的数组元素的存储地 址： LOC ( i1, i2, …, in ) = a + ( i1*m2*m3*…*mn + i2*m3*m4*…*mn+ + ……+ in-1*mn + in ) * l *li)m(ia n j n jk nkj       +∗+= ∑ ∏ − = += 1 1 1 13 特殊矩阵 • 特殊矩阵是指非零元素或零元素的分布有 一定规律的矩阵。 • 特殊矩阵的压缩存储主要是针对阶数很高 的特殊矩阵。为节省存储空间，对可以不 存储的元素，如零元素或对称元素，不再 存储。  对称矩阵  三对角矩阵 14 对称矩阵的压缩存储 • 设有一个 n×n 的对称矩阵 A。  对称矩阵中的元素关于主对角线对称， aij = aji， 0≤i, j≤n-1 15 • 为节约存储，只存对角线及对角线以上的元 素，或者只存对角线或对角线以下的元素。 前者称为上三角矩阵，后者称为下三角矩阵。 下 三 角 矩 阵 16 上 三 角 矩 阵 • 把它们按行存放于一个一维数组 B 中，称之 为对称矩阵 A 的压缩存储方式。 • 数组 B 共有 n + ( n - 1 ) +  + 1 = n*(n+1)／2 个元素。 17 下 三 角 矩 阵 若 i ≥j, 数组元素A[i][j]在数组B中的存放位置 为 1 + 2 +  + i + j = (i + 1)* i / 2 + j B a00 a10 a11 a20 a21 a22 a30 a31 a32 …… an-1n-1 0 1 2 3 4 5 6 7 8 n(n+1)/2-1 前i行元素总数 第i行第j个元素前元素个数 18  若 i < j，数组元素 A[i][j] 在矩阵的上三角部 分, 在数组 B 中没有存放，可以找它的对称 元素A[j][i]：= j *(j +1) / 2 + i  若已知某矩阵元素位于数组 B 的第 k个位置 （k≥0），可寻找满足 i (i + 1) / 2 ≤ k < (i + 1)*(i + 2) / 2 的 i, 此即为该元素的行号。 j = k - i * (i + 1) / 2 此即为该元素的列号。  例，当 k = 8, 3*4 / 2 = 6 ≤ k < 4*5 / 2 =10, 取 i = 3。则 j = 8 - 3*4 / 2 = 2。 19 上 三 角 矩 阵 B a00 a01 a02 a03 a11 a12 a13 a22 a23 a33 0 1 2 3 4 5 6 7 8 9 若i ≤ j，数组元素A[i][j]在数组B中的存放位置 为 n + (n-1) + (n-2) +  + (n-i+1) + j-i 前i行元素总数 第i行第j个元素前元素个数 n = 4 20  若 i ≤ j，数组元素A[i][j]在数组B中的存放位 置为 n + (n-1) + (n-2) +  + (n-i+1) + j-i = = (2*n-i+1) * i / 2 + j-i = = (2*n-i-1) * i / 2 + j  若i > j，数组元素A[i][j]在矩阵的下三角部 分，在数组 B 中没有存放。因此，找它的 对称元素A[j][i]。A[j][i]在数组 B 的第 (2*n- j-1) * j / 2 + i 的位置中找到。 21 三对角矩阵的压缩存储 B a00 a01 a10 a11 a12 a21 a22 a23 … an-1n-2 an-1n-1 0 1 2 3 4 5 6 7 8 9 10 22 • 三对角矩阵中除主对角线及在主对角线上 下 最临近的两条对角线上的元素外，所有其它 元素均为0。总共有3n-2个非零元素。 • 将三对角矩阵A中三条对角线上的元素按行存 放在一维数组 B 中，且a00存放于B[0]。 • 在三条对角线上的元素aij 满足 0 ≤ i ≤ n-1, i-1 ≤ j ≤ i+1 • 在一维数组 B 中 A[i][j] 在第 i 行，它前面有 3*i-1 个非零元素, 在本行中第 j 列前面有 j- i+1 个，所以元素 A[i][j] 在 B 中位置为 k = 2*i + j。 23 • 若已知三对角矩阵中某元素 A[i][j] 在数组 B[ ] 存放于第 k 个位置，则有 i = (k + 1) / 3 j = k - 2 * i • 例如，当 k = 8 时， i = (8+1) / 3 = 3, j = 8 - 2*3 = 2 当 k = 10 时， i = (10+1) / 3 = 3, j = 10 - 2*3 = 4 24 稀疏矩阵 (Sparse Matrix)  设矩阵 A 中有 s 个非零元素，若 s 远远小于 矩阵元素的总数（即s << m×n），则称 A 为稀疏矩阵。 25 • 设矩阵 A 中有 s 个非零元素。令 e = s/(m×n), 称 e 为矩阵的稀疏因子。 • 有人认为 e≤0.05 时称之为稀疏矩阵。 • 在存储稀疏矩阵时，为节省存储空间，应只 存储非零元素。但由于非零元素的分布一般 没有规律，故在存储非零元素时，必须记下 它所在的行和列的位置 ( i, j )。 • 每一个三元组 (i, j, aij) 唯一确定了矩阵A的一 个非零元素。因此，稀疏矩阵可由表示非零 元素的一系列三元组及其行列数唯一确定。 26 稀疏矩阵的定义 const int drows = 6, dcols = 7, dterms = 9; template<class E> struct Triple { //三元组 int row, col; //非零元素行号/列号 E value; //非零元素的值 void operator = (Triple<E>& R) //赋值 { row = R.row; col = R.col; value = R.value; } }; 27 template <class E> class SparseMatrix { public: SparseMatrix (int Rw = drows, int Cl = dcols, int Tm = dterms); //构造函数 void Transpose(SparseMatrix<E>& b); //转置 void Add (SparseMatrix<E>& a, SparseMatrix<E>& b); //a = a+b void Multiply (SparseMatrix<E>& a, SparseMatrix<E>& b); //a = a*b pvivate: int Rows, Cols, Terms; //行／列／非零元素数 Triple<E> *smArray; //三元组表 }; 28 稀疏矩阵的构造函数 template <class E> SparseMatrix<E>::SparseMatrix (int Rw, int Cl, int Tm) { Rows = Rw; Cols = Cl; Terms = Tm; smArray = new Triple[Terms]; //三元组表 if (smArray == NULL) { cerr << “存储分配失败！” << endl; exit(1); } }; 29 稀疏矩阵的转置 • 一个 m×n 的矩阵 A，它的转置矩阵 B 是一 个 n×m 的矩阵，且 A[i][j] = B[j][i]。即  矩阵 A 的行成为矩阵 B 的列  矩阵 A 的列成为矩阵 B 的行。 • 在稀疏矩阵的三元组表中，非零矩阵元素按 行存放。当行号相同时，按列号递增的顺序 存放。 • 稀疏矩阵的转置运算要转化为对应三元组表 的转置。 30 00002800 00000091 03900000 0006000 017000110 150022000                     − 稀疏矩阵 行行 ((rrooww)) 列列 ((ccooll)) 值值 ((vvaalluuee)) [0] 00 33 2222 [1] 00 66 1155 [2] 11 11 1111 [3] 11 55 1177 [4] 22 33 --66 [5] 33 55 3399 [6] 44 00 9911 [7] 55 22 2288 31 转置矩阵 行行 ((rrooww)) 列列 ((ccooll)) 值值 ((vvaalluuee)) [0] 00 44 9911 [1] 11 11 1111 [2] 22 55 2288 [3] 33 00 2222 [4] 33 22 --66 [5] 55 11 1177 [6] 55 33 3399 [7] 66 00 1166 32 用三元组表表示的稀疏矩阵及其转置 行 (row) 列 (col) 值 (value) 行 (row) 列 (col) 值 (value) [0] 0 3 22 [0] 0 4 91 [1] 0 6 15 [1] 1 1 11 [2] 1 1 11 [2] 2 5 28 [3] 1 5 17 [3] 3 0 22 [4] 2 3 -6 [4] 3 2 -6 [5] 3 5 39 [5] 5 1 17 [6] 4 0 91 [6] 5 3 39 [7] 5 2 28 [7] 6 0 16 原矩阵三元组表 转置矩阵三元组表 33 稀疏矩阵转置算法思想 • 设矩阵列数为 Cols，对矩阵三元组表扫描 Cols 次。 • 第 k 次扫描找寻所有列号为 k 的项，将其行 号变列号、列号变行号，顺次存于转置矩阵 三元组表。 34 稀疏矩阵的转置 template <class E> void SparseMatrix<E> :: Transpose (SparseMatrix<E>& B) { //转置this矩阵，转置结果由B返回 B.Rows = Cols; B.Cols = Rows; B.Terms = Terms; //转置矩阵的列数,行数和非零元素个数 if (Terms > 0) { int CurrentB = 0; //转置三元组表存放指针 int i, k; 35 for (k = 0; k < Cols; k++) //处理所有列号 for (i = 0; i < Terms; i++) if (smArray[i].col == k) { B.smArray[CurrentB].row = k; B.smArray[CurrentB].col = smArray[i].row; B.smArray[CurrentB].value= smArray[i].value; CurrentB++; } } }; 36 快速转置算法 • 设矩阵三元组表总共有 t 项，上述算法的时 间代价为 O ( n* t )。当非零元素的个数 t 和 m*n 同数量级时，算法Transpose的时间复杂 度为O(m*n2)。 • 若矩阵有 200 行，200 列，10,000 个非零元 素，总共有 2,000,000 次处理。 • 快速转置算法的思想为：对原矩阵A 扫描一 遍（实际为两遍，建辅助数组需扫描一遍）， 按 A 中每一元素的列号，立即确定在转置矩 阵 B 三元组表中的位置，并装入它。 37 • 为加速转置速度，建立辅助数组 rowSize 和 rowStart：  rowSize记录矩阵转置前各列，即转置矩 阵各行非零元素个数；  rowStart记录转置矩阵各行非零元素在转 置三元组表中开始存放位置。 • 扫描矩阵三元组表，根据某项列号，确定 它转置后的行号, 查 rowStart 表, 按查到 的位置直接将该项存入转置三元组表中。 38 [0] [1] [2] [3] [4] [5] [6] 语 义 rowSize 1 1 1 2 0 2 1 矩阵 A 各列非 零元素个数 rowStart 0 1 2 3 5 5 7 矩阵 B 各行开 始存放位置 A三元组 (0) (1) (2) (3) (4) (5) (6) (7) 行row 0 0 1 1 2 3 4 5 列col 3 6 1 5 3 5 0 2 值value 22 15 11 17 -6 39 91 28 39 稀疏矩阵的快速转置算法 template <class E> void SparseMatrix<E>:: FastTranspose (SparseMatrix<E>& B) { int *rowSize = new int[Cols]; //列元素数数组 int *rowStart = new int[Cols]; //转置位置数组 B.Rows = Cols; B.Cols = Rows; B.Terms = Terms; if (Terms > 0) { int i, j; for (i = 0; i < Cols; i++) rowSize[i] = 0; 40 for (i = 0; i < Terms; i++) rowSize[smArray[i].col]++; rowStart[0] = 0; for (i = 1; i < Cols; i++) rowStart[i] = rowStart[i-1]+rowSize[i-1]; for (i = 0; i < Terms; i++) { j = rowStart [smArray[i].col]; B.smArray[j].row = smArray[i].col; B.smArray[j].col = smArray[i].row; B.smArray[j].value = smArray[i].value; rowStart [smArray[i].col]++; } } delete [ ] rowSize; delete [ ] rowStart; } 41 带行指针数组的二元组表 • 稀疏矩阵的三元组表可以用带行指针数组的 二元组表代替。 • 在行指针数组中元素个数与矩阵行数相等。 第 i 个元素的下标 i 代表矩阵的第 i 行，元素 的内容即为稀疏矩阵第 i 行的第一个非零元 素在二元组表中的存放位置。 42 • 二元组表中每个二元组只记录非零元素的列 号和元素值，且各二元组按行号递增的顺序 排列。 行指针数组 row 0 0 1 3 2 4 3 6 4 -1 5 7 二元组表 data col value 0 0 12 1 2 11 2 5 13 3 6 14 4 1 -4 5 5 3 6 3 8 7 1 -9 8 4 2 43 用正交链表来表示稀疏矩阵  优点：适应矩阵操作(+、-、*)时矩 阵非零元素的动态变化 稀疏矩阵表示为行链表与列链表的十 字交叉——称为正交链表（十字链表） 44 (a) 表头结点 (b) 非零元素结点 a[i][j] False i j (c) 建立a[i][j]结点 • 稀疏矩阵的结点 head row col down value right head next down right 45 稀疏矩阵的正交链表表示的示例 46 字符串 (String) • 字符串是 n ( ≥0 ) 个字符组成的有限序列， 记作 S : “c0c1c2…cn-1” 其中，S 是串名字 “c0c1c2…cn-1”是串值 （默认包含串结束符‘\\0’） ci 是串中字符 n 是串的长度，n = 0 称为空串。 • 例如, S = “Nanjing University”。 • 注意：空串和空白串不同，例如 “ ” 和 “” 分别表示长度为1的空白串和长度为0的空串。 47 • 串中任意个连续字符组成的子序列称为该串 的子串，包含子串的串相应地称为主串。 • 设A和B分别为 A = “This is a string” B = “is” 则 B 是 A 的子串，A 为主串。B 在 A 中出现 了两次，首次出现所对应的主串位置是2（从 0开始）。因此，称 B 在 A 中的位置为2。 • 特别地，空串是任意串的子串，任意串是其 自身的子串。 48 字符串的类定义 #ifndef ASTRING_H //定义在文件“Astring.h”中 #define ASTRING_H #define defaultSize = 128; //字符串的最大长度 class AString { //对象: 零个或多个字符组成的一个有限序列。 private: char *ch; //串存放数组 int curLength; //串的实际长度 int maxSize; //存放数组的最大长度 49 public: AString(int sz = defaultSize); //构造函数 AString(const char *init ); //构造函数 AString(const AString& ob); //复制构造函数 ～AString() {delete [ ]ch; } //析构函数 int Length() const { return curLength; } //求长度 Astring& operator() (int pos, int len); //求子串 bool operator == (AString& ob) const { return strcmp (ch, ob.ch) == 0; } //判串相等. 若串相等, 则函数返回true bool operator != (AString& ob) const { return strcmp (ch, ob.ch) != 0; } //判串不等. 若串不相等, 则函数返回true 50 bool operator ! () const { return curLength == 0; } //判串空否。若串空, 则函数返回true AString& operator = (AString& ob); //串赋值 AString& operator += (AString& ob); //串连接 char& operator [ ] (int i); //取第 i 个字符 int Find (AString& pat, int start) const; //串匹配 }; 51 字符串的构造函数 AString::AString(int sz) { //构造函数：创建一个空串 maxSize = sz; ch = new char[maxSize+1]; //创建串数组 if (ch == NULL) { cerr << “存储分配错!\\n”; exit(1); } curLength = 0; ch[0] = ‘\\0’; }; 52 字符串的构造函数 AString::AString(const char *init) { //复制构造函数: 从已有字符数组*init复制 int len = strlen(init); maxSize = (len > defaultSize) ? len : defaultSize; ch = new char[maxSize+1]; //创建串数组 if (ch == NULL) { cerr << “存储分配错 ! \\n”; exit(1); } curLength = len; //复制串长度 strcpy(ch, init); //复制串值 }； 53 字符串的复制构造函数 AString :: AString(const AString& ob) { //复制构造函数：从已有串ob复制 maxSize = ob.maxSize; //复制串最大长度 ch = new char[maxSize +1]; //创建串数组 if (ch == NULL) { cerr << “存储分配错! \\n”; exit(1); } curLength = ob.curLength; //复制串长度 strcpy(ch, ob.ch); //复制串值 }; 54 字符串重载操作的使用示例 序 号 重载操作 操作 使用示例 (设使用操作的当 前串为S：‘good’) 1 ( ) (int pos, int len) 取子串 S1 = S(1, 3), //S1结果为 ‘ood’ 2 == (const AString& ob) 判两串 相等 S == S1 , //若S与S1相等, 结果为true，否则为false 3 != (const AString& ob) 判两串 不等 S != S1 , //若S与S1不等， 结果为true，否则为false 4 ! () 判串空 否 !S , //若串S为空，结果为 true，否则为false 55 序 号 重载操作 操作 使用示例 (设使用操作的 当前串为S：‘good’) 5 = (const AString& ob) 串赋值 S1 = S, //S1结果为‘good’ 6 += (const AString& ob) 串连接 若设S1为‘ morning’, 执 行S += S1, //S结果为 ‘good morning’ 7 [ ] (int i) 取第 i 个字符 S[3], //取出字符为‘d’ 56 提取子串的算法示例 pos+len-1 pos+len -1 ≤ curLength-1 ≥curLength 可以全部提取 只能从pos取到串尾 i n f i n i t y i n f i n i t y pos = 2, len = 3 pos = 5, len = 4 f i n i t y 超出 57 串重载操作：提取子串 AString AString::operator () (int pos, int len) { //从串中第 pos 个位置起连续提取 len 个字符形成 //子串返回 AString temp; //建立空串对象 if (pos >= 0 && pos+len-1 < maxSize && len > 0) { //提取子串 if (pos+len-1 >= curLength) len = curLength - pos; //调整提取字符数 temp.curLength = len; //子串长度 58 for (int i = 0, j = pos; i < len; i++, j++) temp.ch[i] = ch[j]; //传送串数组 temp.ch[len] = ‘\\0’; //子串结束 } return temp; }; • 例：串 st = “university”, pos = 3, len = 4 使用示例 subSt = st(3, 4) 提取子串 subSt = “vers” 59 串重载操作: 串赋值 AString& AString::operator = (const AString& ob) { if (&ob != this) { //若两个串相等为自我赋值 delete []ch; ch = new char[maxSize+1]; //重新分配 if (ch == NULL) { cerr << “存储分配失败!\\n ”; exit(1); } curLength = ob.curLength; strcpy(ch,ob.ch); } else cout << “字符串自身赋值出错!\\n”; return this; }; 60 串重载操作：取串的第i个字符 char AString::operator [ ] (int i) { //串重载操作：取当前串*this的第i个字符 if (i < 0 || i >= curLength) { cout << “字符串下标超界!\\n ”; exit(1); } return ch[i]; }; • 例：串 st = “university”, 使用示例 newSt = st；newChar = st[1]; 数组赋值结果 newSt = “university” 提取字符结果 newChar = ‘n’ 61 串重载操作: 串连接 AString& AString::operator += (const AString& ob) { char *temp = ch; //暂存原串数组 int n = curLength + ob.curLength; //串长度累加 int m = (maxSize >= n) ? maxSize : n; //新空间大小 ch = new char[m]; if (ch == NULL) { cerr << “存储分配错!\\n ”; exit(1); } maxSize = m; curLength = n; strcpy(ch, temp); //拷贝原串数组 strcat(ch, ob.ch); //连接ob串数组 62 delete []temp; return this; }; • 例：串 st1 = “Nanjing ”, st2 = “university”, 使用示例 st1 += st2; 连接结果 st1 = “Nanjing university” st2 = “university” 63 串的模式匹配 • 定义 在主串中寻找子串（第一个字符）在 串中的位置 • 词汇 在模式匹配中，子串称为模式，主串 称为目标。 • 示例 目标 T : “Nanjing” 模式 P : “jin” 匹配结果 = 3 64 朴素的模式匹配 第1趟 T a b b a b a P a b a 第2趟 T a b b a b a P a b a i=2 j=2 i=1 j=0 第3趟 T a b b a b a P a b a 第4趟 T a b b a b a P a b a i=2 j=0 i=6 j=3 65 朴素的模式匹配算法 int AString::Find(AString& pat, int start) const { //在当前串中从第 start 个字符开始寻找模式 pat 在当 //前串中匹配的位置。若匹配成功, 则函数返回首 //次匹配的位置, 否则返回-1。 int i, j, n = curLength, m = pat.curLength; if (m == 0) return -1; //pat为空 for (i = start; i <= n-m; i++) { for (j = 0; j < m; j++){ if (ch[i+j] != pat.ch[j]) break; //本次失配 } if (j == m) return i; //pat扫描完, 匹配成功 } return -1; //在*this中找不到子串 }; 66 • 在最坏情况下，若设 n 为目标串长度，m 为 模式串长度，则匹配算法最多比较 n-m+1 趟，每趟比较都在比较到模式串尾部才出现 不等，要做 m 次比较，总比较次数将达到 (n-m+1)*m。在多数场合下 m 远小于 n， 因此，算法的运行时间为O(n*m)。 • 低效的原因在于每趟重新比较时，目标串的 检测指针要回退。 67 改进的模式匹配 • 只要消除了每趟失配后为实施下一趟比较时 目标指针的回退，就可以提高模式匹配效率。 • 这种处理思想是由D.E.Knuth、J.H.Morris和 V.R.Pratt同时提出来的，故称为KMP算法。 68 目标 T t0 t1 t2 …… tm-1 … tn-1     模式 P p0 p1 p2 …… pm-1 目标 T t0 t1 t2 …… tm-1 tm … tn-1     模式 P p0 p1 …… pm-2 pm-1 目标 T t0 t1 …… ti ti+1…… ti+m-2 ti+m-1… tn-1 ‖ ‖ ‖ ‖ 模式 P p0 p1 …… pm-2 pm-1 改进的模式匹配 69 T t0 t1 … ts-1 ts ts+1 ts+2 … ts+j-1 ts+j ts+j+1 … tn-1 ‖ ‖ ‖ ‖ ‖ × P p0 p1 p2 … pj-1 pj 则有 ts ts+1 ts+2 … ts+j-1 = p0 p1 p2 …pj-1 (1) 下一趟，为使模式 P 与目标 T 匹配，必须满足 p0 p1 p2 …pj-1 …pm-1 = ts+1 ts+2 ts+3 … ts+j … ts+m 如果 p0 p1 … pj-2 ≠ p1 p2 …pj-1 (2) 则立刻可以断定 p0 p1 …pj-2 ≠ ts+1 ts+2 … ts+j-1 下一趟必不匹配 p0 p1 … pj-2 70 同样，若 p0 p1 …pj-3 ≠ p2 p3 …pj-1 则再下一趟也不匹配，因为有 p0 p1 …pj-3 ≠ ts+2 ts+3 … ts+j-1 直到对于某一个“k”值，使得 p0 p1 …pk+1 ≠ pj-k-2 pj-k-1 …pj-1 且 p0 p1 …pk = pj-k-1 pj-k …pj-1 则 p0 p1 …pk = ts+j-k-1 ts+j-k … ts+j-1 ‖ ‖ ‖ pj-k-1 pj-k … pj-1 下一趟可以直接用 pk+1 与 ts+j 继续比较。 71 k 的确定方法 • Knuth 等人发现，对于不同的 j（失配位 置），k 的取值不同，它仅依赖于模式 P 本 身前 j 个字符的构成，与目标无关。 • 可以用一个 next 特征向量来确定：当模式 P 中第 j 个字符与目标 T 中相应字符失配时， 模式 P 中应当由哪个字符（设为第k+1个） 与目标中刚失配的字符重新继续进行比较。 72 • 设模式 P = p0p1...pm-2pm-1，next特征向量定 义如下： • 示例        =−<≤ + =− = −−−− 其他情况 的最大整数 且使得 0, ...ppp ...ppp1jk0 1,k 0j1, next(j) 1jkj1kj k10 j 0 1 2 3 4 5 6 7 P a b a a b c a c next(j) -1 0 0 1 1 2 0 1 73 利用next特征向量进行匹配处理 • 若设在进行某一趟匹配比较时在模式 P 的第 j 位失配：  如果 j > 0，那么在下一趟比较时模式串 P 的起始比较位置是 pnext(j)，目标串 T 的指 针不回溯，仍指向上一趟失配的字符；  如果 j = 0，则目标串指针 T 进一，模式串 指针 P 回到 p0，继续进行下一趟匹配比较。 74 运用KMP算法的匹配过程 第1趟 目标 a c a b a a b a a b c a c a a b c 模式 a b a a b c a c × j=1  next(1) = 0，下次p0 第2趟 目标 a c a b a a b a a b c a c a a b c 模式 a b a a b c a c × j=0  下次p0, 目标指针进 1 第3趟 目标 a c a b a a b a a b c a c a a b c 模式 a b a a b c a c ×j=5  next(5) = 2, 下次p2 第4趟 目标 a c a b a a b a a b c a c a a b c 模式 (a b) a a b c a c √ 75 用KMP算法实现快速匹配算法 int AString::fastFind(AString& pat, int start, int next[]) const { //从 start 开始寻找 pat 在 this 串中匹配的位置。若找 //到，函数返回 pat 在 this 串中开始位置，否则函 //数返回-1。数组next[ ] 存放 pat 的next[j] 值。 int posP = 0, posT = start; //两个串的扫描指针 int lengthP = pat.curLength; //模式串长度 int lengthT = curLength; //目标串长度 while (posP < lengthP && posT < lengthT) { if (posP == -1 || pat.ch[posP] == ch[posT]) { posP++; posT++; } //对应字符匹配 else posP = next[posP]; //求pat下趟比较位置 } if (posP < lengthP) return -1; //匹配失败 else return posT-lengthP; //匹配成功 }; 76 • 此算法的时间复杂度取决于 while 循环。由于是 无回溯的算法，执行循环时，目标串字符比较有 进无退，要么执行 posT 和 posP 进 1，要么查找 next[ ] 数组进行模式位置的右移，然后继续向后 比较。 • 若设 n 为目标串长度，m 为模式串长度，字符 的比较次数最多为 O(n)，不超过目标串的长度。 77 next特征向量的计算 • 设模式 P = p0 p1 p2 …pm-1由 m 个字符组成， 而next特征向量为next = n0 n1 n2 … nm-1，表 示了模式的字符分布特征。 • next特征向量从0, 1, 2, …, m-1逐项递推计算:  当 j = 0时，n0 = -1。设 j > 0 时 nj-1 = =k:  当 k == -1或 ( j > 0且 pj-1 == pk ) ，则 nj = k+1。  当 pj-1 ≠ pk 且 k ≠ -1，令 k = nk，并让循 环直到条件不满足, nj = k+1 78 • 以前面的例子说明： j 0 1 2 3 4 5 6 7 P a b a a b c a c next [j] -1 0 0 1 1 2 0 1 j=4 k=1 p3≠p1 k=nk=0 p3=p0 n4= =k+1 =1 j=3 k=0 n3= =k+1 =1 j=2 k=0 p1≠p0 k=nk= =-1 n2= k+1 =0 j=1 k=-1 n1= =k+1 =0 j=0 n0=-1 j=5 k=1 p4=p1 n5= =k+1 =2 j=6 k=2 p5≠p2 k=nk=0 p5≠p0 k=nk=-1 n6=k+1=0 j=7 k=0 p6=p0 n7=k+1 =1 79 对当前串计算next特征向量的算法 void AString::getNext(int next[]) { int j = 0, k = -1, lengthP = curLength; next[0] = -1; j = 1; while (j < lengthP) { //计算next[j] k = next[j-1]; while(1) { if ( k == -1 || ch[j-1] == ch[k]) { k++; next[j] = k; j++; break; } else k = next[k]; } } }; 80 广义表 (General Lists ) • 广义表是 n ( ≥0 ) 个表元素组成的有 限序列，记作 LS (a1, a2, a3, …, an) • LS 是表名，ai 是表元素，可以是表 （称为子表），可以是数据元素（称 为原子）。 • n为表的长度。n = 0 的广义表为空表。 81 G = ( ‘a’, ( 5, 3, ‘x’ ) , …) 原子 子表 表头 表尾 •n > 0时，表的第一个表元素称为广义表 的 表头（head），除此之外，其它表元素组 成的表称为广义表的表尾（tail）。 82 广义表的特性 • 有次序性 • 有长度 • 有深度 • 可共享 • 可递归 A( ) A长度为0，深度为1 B( 6, 2 ) B长度为2，深度为1 C( ‘a’, ( 5, 3, ‘x’ ) ) C长度为2，深度为2 D( B, C, A ) D长度为3，深度为3 E( B, D ) E长度为？ 深度为？ F( 4, F ) F长度为？ 深度为？ 83 广义表的表头与表尾 • 广义表的第一个表元素即为该表的表头，除 表头元素外其他表元素组成的表即为该表的 表尾。 A( ) head(A) 和 tail(A) 不存在 B( 6, 2 ) head(B) = 6, tail(B) = (2) C( ‘a’, ( 5, 3, ‘x’ ) ) head(C) =‘a’ D( B, C, A ) tail(C) = ((5,3, ‘x’)) E( B, D ) head( ((5,3, ‘x’)) ) = (5,3, ‘x’) F( 4, F ) tail( ((5,3, ‘x’)) ) = ( ) 84 A B C u v a x y z D u v a x y z B C A u v a x y z B C A E D 空表 线性表 再入表 纯表 (树) F 递归表 d 85 广义表的表示 list1 = (a, b, c, d, e) list2 = (a, (b, c, (d, e, f), (), g), h, (r, s, t)) a h b c g sr t fed ∧ ∧ ∧ ∧ ∧list2 alist1 b d ec ∧ 86 广义表结点定义 • 结点类型 utype：= 0, 表头；= 1, 原子数据； = 2, 子表 • 信息info：utype = 0时, 存放引用计数(ref)； utype = 1时, 存放数据值(value)；utype = 2 时, 存放指向子表表头的指针(hlink) • 尾指针tlink：utype = 0时, 指向该表第一个 结点；utype ≠ 0时, 指向同一层下一个结点 utype info tlink 87 广义表的存储表示 E B F 0 1 1 h 2 0 0 22 D ∧ ∧ 0 1 1 d 1 e 1 f ∧ 0 1 1 c 2 ∧C ∧0 1 2 2 2 0 2 1 a D B B C A 1 b ∧ 0 1 A ∧ 88 G G 广义表的类定义 template <class T> struct GenListNode { //广义表结点类定义 int utype; //＝0 / 1 / 2 GenListNode<T> *tlink; //同层下一结点指针 union { //等价变量 int ref; //存放引用计数 T value; //存放数值 GenListNode<T> *hlink; //存放子表指针 } info; GenListNode() //构造函数 : utype(0), tlink(NULL), info.ref(0) {} GenListNode(GenListNode<T>& R) { //复制构造函数 utype = R.utype; tlink = R.tlink; info = R.info; } }; 89 template <class T> class GenList { //广义表类定义 public: Genlist(); //构造函数 ～GenList(); //析构函数 bool Head (GenListNode<T>& x); //x 返回表头元素 bool Tail (GenList<T>& lt); //lt 返回表尾 GenListNode<T> *First(); //返回第一个元素地址 GenListNode<T> *Next (GenListNode<T> *elem); //返回表元素elem的直接后继元素 void Copy ( const GenList<T>& R); //广义表的复制 int Length(); //计算广义表长度 int Depth(); //计算非递归表深度 90 private: GenListNode<T> *first; //广义表头指针 GenListNode<T> *Copy (GenListNode<T> *ls); //复制一个ls指示的无共享非递归表 int Length (GenListNode<T> *ls); //求由ls指示的广义表的长度 int Depth (GenListNode<T> *ls); //计算由ls指示的非递归表的深度 bool Equal (GenListNode<T> *s, GenListNode<T> *t); //判以s和t为表头的两个表是否相等 void Remove (GenListNode<T> *ls); //释放以ls为附加头结点的广义表 91 void CreateList (istream &in, GenListNode<T> *& ls, SeqList<T>& L1, SeqList <GenListNode<T> *>& L2); //从输入流对象输入广义表的字符串描述, //建立一个带头结点的广义表结构 friend istream& operator >> (istream& in, GenList<T>& L); }; 92 广义表类的构造和访问成员函数 template <class T> Genlist<T>::GenList() { //构造函数 GenListNode<T> * first = new GenListNode; if (first == NULL) { cerr << “存储分配失败！\\n”; exit(1); } }; template <class T> bool GenList<T>::Head (GenListNode <T>& x) { //若广义表非空，则通过x返回其第一个元素的值 //否则函数没有定义 if (first->tlink == NULL) return false; //空表 else { //非空表 x.utype = first->tlink->utype; x.info = first->tlink->info; return true; //x返回表头的值 } }; 93 template <class T> bool GenList<T>::Tail(GenList<T>& lt) { //若广义表非空，则通过lt返回广义表除表头元素 //以外其他元素组成的表，否则函数没有定义 if (first->tlink == NULL) return false; //空表 else { //非空表 lt.first->utype = 0; //设置头结点 lt.first->info.ref = 0; lt.first->tlink = Copy(first->tlink->tlink); return true; } }; 94 template <class T> GenListNode<T> *GenList<T>::First() { //返回广义表的第一个元素（若表空，则返回一个 //特定的空值NULL） if (first->tlink == NULL) return NULL; //空表 else return first->tlink; //非空表 }; 95 template <class T> GenListNode<T> *GenList<T>:: Next(GenListNode<T> *elem) { //返回表元素elem的直接后继元素 if (elem->tlink == NULL) return NULL; else return elem->tlink; }; 96 广义表的递归算法 • 一个递归算法有两种：一个是递归函数的外 部调用；另一个是递归函数的内部调用。 • 通常，把外部调用设置为公有函数，把内部 调用设置为私有函数。 97 template <class T> //公有函数 void GenList<T>::Copy(const GenList<T>& R) first = Copy(R.first); //调用私有函数 }; 98 广义表的复制算法 template <class T> //私有函数 GenListNode<T>* GenList<T>::Copy(GenListNode <T> *ls) { //复制一个 ls 指示的无共享子表的非递归表 GenListNode<T> *q = NULL; if (ls != NULL) { q = new GenListNode<T>; //处理当前的结点q q->utype = ls->utype; //复制结点类型 switch (ls->utype) { //根据utype传送信息 case 0: q->info.ref = ls->info.ref; break; case 1: q->info.value = ls->info.value; break; case 2: q->info.hlink = Copy(ls->info.hlink); break; } q->tlink = Copy(ls->tlink); //处理同层下一结点 } return q; }; 99 0 1 1 a 1 b ∧ 0 1 2 1 e ∧ 2 0 1 1 c 1 d ∧ 20 0 ∧ls 100 1 1 1 1 2 3 4 求广义表深度的算法 • 例如，对于广义表 E (B (a, b), D (B (a, b), C (u, (x, y, z)), A ( ) ) )       ≥+ = −≤≤ 1n,)},{Depth(αmax1 LS0, LS1, Depth(LS) i 1ni0 其他 为原子时当 为空表时当 101 template <class T> int GenList<T>::Depth() { //公有函数 //计算一个非递归表的深度 return Depth(first); }; template <class T> //私有函数 int GenList<T>::Depth(GenListNode<T> *ls) { if (ls->tlink == NULL) return 1; // ls->tlink ==NULL, 空表，深度为1 GenListNode<T> *temp = ls->tlink; int m = 0, n; 102 while (temp != NULL) { //在广义表顶层横扫 if (temp->utype == 2) { //扫描到表结点 n = Depth(temp->info.hlink); //递归计算以子表深度 if (m < n) m = n; //取最大深度 } temp = temp->tlink; } return m+1; //返回深度 }; 103 0 1 1 a 2 2 1 b ∧ 0 1 1 c ∧ 0 1 0 11 d ls 2 1 c ∧ ∧ 广义表的删除算法 • 扫描子链表  若结点数据为c, 删除。可能做循环连续删。  若结点数据不为c，不执行删除。  若结点为子表，递归在子表执行删除。 104 template <class T> void delvalue(GenListNode<T> *ls, T x) { if (ls->tlink != NULL) { //非空表 GenListNode<T> * p = ls->tlink; //第一个结点 while (p != NULL && (p->utype == 1 && p->info.value == x)) { ls->tlink = p->tlink; delete p; p = ls->tlink; //p指向同层下一结点 } if (p != NULL) { if (p->utype == 2) //递归在子表中删除 delvalue(p->info.hlink, x); delvalue(p, x); //在以p为表头的链表中递归删除 } } }; 105 • 删除子表： – 对于共享表来说，如果一个表元素有多个地方使用 它，贸然删去它会造成其他地方使用出错。因此， 当要做删除时，先把该表的头结点中的引用计数 ref 减1，当引用计数减到 0 时才能执行结点的真正 释放。 template <class T> GenList<T>::～GenList() { //广义表的析构函数, 每个头结点都有引用计数 Remove(first); delete first; //first要额外处理 }; 106 template <class T> void GenList<T>::Remove(GenListNode<T> *ls) { //私有函数：释放以ls为表头指针的广义表 ls->info.ref--; //头结点的引用计数减1 if (ls->info.ref <= 0) { //如果减到0 GenListNode<T> *q; while (ls->tlink != NULL) { //横扫表顶层 q = ls->tlink; //到第一个结点 if (q->utype == 2) { //递归删除子表 Remove(q->info.hlink); if (q->info.hlink->info.ref <= 0) delete q->info.hlink; //删子表头结点 } ls->tlink = q->tlink; delete q; } } }; 107 • 例：给出下面的广义表进行删除时的结点 删除的顺序 108 据字符串描述生成广义表链表结构 设广义表的字符串描述如下 S(A ( ‘b’, ‘c’ ), B(‘#’), ‘d’ )； 建立广义表的链表表示 109 • 假设一个广义表的元素类型 T 是字符类型 char，每一个原子元素的值为英文字母，并 假定广义表从输入流对象 istream 输入。 • 在算法的执行过程中，检测从输入流对象输 入的一个字符，如果遇到表名（用大写字母 表示），首先检查这个表名是否已经存在， 如果是，说明该表是共享表，只要将相应头 结点的引用计数加一即可；如果不是，保存 该表名并建立相应广义表。表名后面一定是 左括号‘(’，不是则输入错，是则递归建立广 义表结构。 110 • 如果遇到用小写字母表示的原子，则建立原 子结点；如果遇到右括号‘)’，子表链收尾并 退出递归。 • 注意在空表情形括号里应夹入一个非英文字 母，如字符'#'，不能一个字符也没有。整个 广义表描述字符串以';'结束。 111 由字符串建立广义表的链表表示算法 #include <string.h> template <class T> void Genlist<T>::CreateList(istream &in, GenListNode<T> *& ls, SeqList<T>& L1, SeqList <GenListNode<T> *>& L2) { //从广义表的字符串描述 s 出发, 建立一个带头结 //点的广义表，要求T为char类型。在表L1存储大 //写字母的表名, 在表L2存储表名对应子表结点的 //地址。 T chr; in >> chr; 112 //读入一个字符，只可能读入#、左括号和字母 if (isalpha(chr) && isupper(chr) ) { //大写字母 ls = new GenListNode<T>; //建子表结点 ls->utype = 2; if (isalpha(chr) && isupper(chr)) { //表名处理 int n = L1.Length(); int m = L1.Search(chr); if (m != 0) { //该表已建立 GenListNode<T> *p = L2.Locate(m); //查子表地址 ls->info.hlink = p; p->ref++; //引用计数加一 } 113 else { //该表未建立 L1.Insert(n, chr); L2.Insert(n, ls); //保存表名及地址 in >> chr; if (chr != '(') exit(1); //表名后必跟'(‘ ls->info.hlink = new GenListNode<T>; ls->info.hlink->utype = 0; //建头结点 ls->info.hlink->ref = 1; CreateList(in, ls->info.hlink->tlink, L1, L2); //递归建子表 } CreateList(in, ls, L1, L2); //递归建后继表 114 } else if (isalpha(chr) && islower(chr)) { //建原子结点 ls = new GenListNode<T>; ls->utype = 1; ls->info.value = chr; CreateList(in, ls, L1, L2); } else if (chr == ', ') //建后继结点 CreateList(in, ls->tlink, L1, L2); else if (chr == ')') ls->tlink = NULL; //链收尾 else if (chr == '#') ls == NULL; //空表, 链收尾 }; 115 • 该算法需要扫描输入广义表中的所有字符， 且处理每个字符都是简单比较或赋值操作， 其时间复杂度为O(1)，所以整个算法的时间 复杂度为O(n)，n是广义表中所有字符数。 • 算法中既包含向子表的递归调用，也包含向 后继表的递归调用，所以递归调用的最大深 度不会超过生成的广义表中所有结点数，其 空间复杂度也为O(n)。 116 template <class T> istream& operator >> (istream& in, GenList<T>& L) { int n; cout << “输入广义表串的字符个数：”<< endl; in >> n; SeqList<T> Ls1(n); SeqList <GenListNode<T> *> Ls2 (n); CreateList (in, L.first, Ls1, Ls2); //建立存储结构 }; 117","libVersion":"0.2.4","langs":""}