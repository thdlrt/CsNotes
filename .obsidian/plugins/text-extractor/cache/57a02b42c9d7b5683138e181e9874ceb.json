{"path":"归档课程/数据结构/课件/线性表.pdf","text":"1 第二章 线性表  线性表  顺序表  单链表  循环链表  双向链表  多项式 线性表的物理实现 单链表的变化形式 链表的应用 2 第二章 线性表 §2.1 线性表 • 定义 n（ ≥ 0）个表项的有限序列 L =（a1, a2, …, an） – ai是表项，n是表长度。 – 第一个表项是表头，最后一个是表尾 • 线性表的特点 – 为简单起见，假定表中元素的数据类型 相同 – 线性表中，结点和结点间的关系是一 对一的 – 有序表和无序表 • 线性表的存储方式 – 顺序存储方式 —— 顺序表 – 链表存储方式 —— 链表 a1 a2 a3 a4 a5 a6 3 §2.2 顺序表  顺序表可用一维数组实现    >+− = = 时 0,)( 时 0α, )( iliLOC i iLOC 1 LOC ( i ) = LOC ( i -1 ) + l =α+ i*l 4 顺序表的定义 -将线性表中的元素相继存放在一个连续的 存储空间中 顺序表的特点 -各表项的逻辑顺序与物理顺序一致 -对各个表项可以顺序访问，也可以随机访 问 56 结点的变体（异质数据） • 若想在线性表中存放不同类型的数据，可采用等价 定义union： typedef union { int val; //按data.val引用 char ch; //按data.ch引用 float dir; //按data.dir引用 union data *link; //按data.link引用 } data; //整体上是同一类型data 25 ‘s’ 3.3 62 74 ‘t’ 1.0 ‘6’ 7 顺序表(SeqList)类的定义 #include <iostream.h> //定义在“seqList.h”中 #include <stdlib.h> #include “linearList.h\" const int defaultSize = 100; template < class E> class SeqList: public LinearList<E> { protected: E *data; //存放数组 int maxSize; //最大可容纳表项的项数 int last; //当前已存表项的最后位置 void reSize(int newSize); //改变数组空间大小 8 public: SeqList(int sz = defaultSize); //构造函数 SeqList(SeqList<E>& L); //复制构造函数 ～SeqList() {delete[ ] data;} //析构函数 int Size() const {return maxSize;} //求表最大容量 int Length() const {return last+1;} //计算表长度 int Search(E& x) const; //搜索x在表中位置，函数返回表项序号 int Locate(int i) const; //定位第 i 个表项，函数返回表项序号 bool getData(int i, E& x) const; //取第i个表项的值 bool Insert(int i, E x); //插入 bool Remove(int i, E& x); //删除 }; 9 顺序表的构造函数 #include <stdlib.h> //操作“exit”存放在此 #include “seqList.h” //操作实现放在“seqList.cpp” template <class E> SeqList<E>::SeqList(int sz) { if (sz > 0) { maxSize = sz; last = -1; data = new E[maxSize]; //创建表存储数组 if (data == NULL){ //动态分配失败 cerr << \"存储分配错误！\" << endl; exit(1); } } }; 10 template <class E> SeqList<E>::SeqList ( SeqList<E>& L ) { maxSize = L.Size(); last = L.Length()-1; E value; data = new E[maxSize]; //创建存储数组 if (data == NULL) //动态分配失败 {cerr << \"存储分配错误！\" << endl; exit(1);} for (int i = 1; i <= last+1; i++) //传送各个表项 {L.getData(i, value); data[i-1] = value;} }; 复制构造函数 11 顺序表的搜索算法 template <class E> int SeqList<E>::Search(E & x) const { //在表中顺序搜索与给定值 x 匹配的表项，找到则 //函数返回该表项是第几个元素，否则函数返回0 for (int i = 0; i <= last; i++) //顺序搜索 if ( data[i] == x ) return i+1; //表项序号和表项位置差1 return 0; //搜索失败 }; 顺序表的搜索（查找） x = 48 x = 50 12 2 1 2)(11 )2(1 11 = 1 nnn n n n i n ACN n i + = ∗+ ∗= =+++=∑ =  顺序查找数据的时间代价（比较次数分析） 搜索成功：表项i的查找概率pi，比较次数ci 若搜索概率pi 相等，则 平均比较次数 搜索不成功：数据比较n次 ACN(Average Comparing Number) (假设表的长度为n,即n = last + 1) 13 ∑ = n i ii c*pACN 1 = 顺序表的插入 1415 表项的插入算法 template <class E> bool SeqList<E>::Insert (int i, E x) { //将新元素x插入到表中第i (1≤i≤last+2) 个表项位 //置。 if (last == maxSize-1) return false; //表满 if (i < 1 || i > last+2) return false; //参数i不合理 for (int j = last; j >= i-1; j--) //依次后移 data[j+1] = data[j]; data[i-1] = x; //插入(第 i 表项在data[i-1]处) last++; return true; //插入成功 }; 平均数据移动次数AMN（Average Moving Number）在各表项插入概率相等时为 顺序表插入的时间代价（移动次数） 在插入时有n+1个插入位置，平均移动n/2项 在表中第 i 个位置插入，从data[i-1] 到data [last] 成块后移， 移动n-1-(i-1)+1 = n-i+1项 (假设表的长度为n,即n = last + 1) 22 1)( 1)( 1 0)1( 1 1 1)( 1 1 = 1 1 nnn n n n in n n i = + + = +++ + =+− + ∑ + = AMN 16 顺序表的表项删除 1718 表项的删除算法 template <class E> bool SeqList<E>::Remove (int i, E& x) { //从表中删除第 i (1≤i≤last+1) 个表项，通过引用型 //参数 x 返回被删元素。 if (last == -1) return false; //表空 if (i < 1 || i > last+1) return false;//参数i不合理 x = data[i-1]; for (int j = i; j <= last; j++) //依次前移，填补 data[j-1] = data[j]; last--; return true; }; 平均数据移动次数AMN（Average Moving Number）在n个表项删除概率相等时为 顺序表表项删除的时间代价(移动次数) 在删除时有n个删除位置，平均移动(n-1)/2项 删除第 i 个表项，需将第 i+1 项到第 last+1项全部前移，需前 移的项数为 n-(i+1)+1 = n-i (假设表的长度为n,即n = last + 1) ∑ = − = − =− n i nnn n in n 1 2 1 2 1)(1 )( 1 =AMN 19 顺序表的应用： void Union ( SeqList<int> & LA, SeqList<int> & LB ) { int n = LA.Length ( ); int m = LB.Length ( ); int x; for ( int i = 1; i <= m; i++ ) { LB.getData(i, x); //在LB中取一元素 int k = LA.Search (x); //在LA中搜索它 if ( k == 0 ) //若未找到插入它 {n++; LA.Insert (n, x);} } } 用顺序表实现集合的“并”运算 20 void Intersection ( SeqList<int> & LA, SeqList<int> & LB ) { int n = LA.Length ( ); int m = LB.Length ( ); int i = 1; int x; while ( i <= n ) { LA.getData (i, x); //在LA中取一元素 int k = LB.Search (x); //在LB中搜索它 if ( k == 0 ) { LA.Remove (i,x); n--;} //未找到,在LA中删除它 else i++; } } 用顺序表实现集合的“交”运算 21 连续存储方式（顺序表）  特点：存储利用率高，存取速度快  缺点：插入、删除等操作时需要移动大量 数据 链式存储方式（链表）  特点：适应表的动态增长和删除  缺点：需要额外的指针存储空间 §2.3 单链表 22 • 单链表的特点 – 每个元素(表项)由结点(Node)构成。 – 线性结构 – 结点可以不连续存储 – 表长度可方便地扩充 23 单链表的存储映像 24 单链表的类定义 • 多个类表达一个概念(单链表)。 – 链表结点(LinkNode)类 – 链表(List)类 25 定义方式 — 结构方式 — 复合方式 — 嵌套方式 — 继承方式 26 struct LinkNode { //链表结点结构 int data; //结点数据, 整型 LinkNode * link; //结点指针 }; class List { //链表类 public: … private: LinkNode *first ; //表头指针 }; 链表类定义（结构方式） 27 class List; //复合方式 class LinkNode { //链表结点类 friend class List; //链表类为其友元类 private: int data; //结点数据, 整型 LinkNode * link; //结点指针 }; class List { //链表类 private: LinkNode *first ; //表头指针 }; 链表类定义（复合方式） 28 class List { //链表类 public: … private: class LinkNode { //链表结点类 public: int data; //结点数据, 整型 LinkNode * link; //结点指针 }; LinkNode *first ; //表头指针 }; 链表类定义（嵌套方式） 29 class LinkNode { //链表结点类 protected: int data; //结点数据, 整型 LinkNode * link; //结点指针 }; class List: pubic class LinkNode { //链表类 public: … private: LinkNode *first ; //表头指针 }; 链表类定义（继承方式） 3031 单链表中的插入与删除操作 • 插入  第一种情况：在链表最前端插入 newNode->link = first ; first = newNode; （插入前） （插入后） first newNode newNode first (插入前) (插入后) 32  第二种情况：在链表中间插入 newNode->link = current->link; current->link = newNode； newNode current newNode current 33  第三种情况：在链表末尾插入 newNode->link = current->link; current->link = newNode； (插入前) (插入后) newNode newNode current current ∧ ∧ 34 单链表的插入算法 bool List::Insert(int i, int x) { //将新元素 x 插入到第 i 个结点之后。i 从1开始， //i = 0 表示插入到首元结点之前。 if (first == NULL || i == 0) { //空表或首元结点前 LinkNode *newNode = new LinkNode(x); //建立一个新结点 newNode->link = first; first = newNode; //新结点成为首元结点 } else { //否则，寻找插入位置 LinkNode *current = first; int k = 1; 35 while (k < i && current != NULL) //找第i结点 { current = current->link; k++; } if (current == NULL && first != NULL) //链短 {cerr << “无效的插入位置!\\n”; return false;} else { //插入在链表的中间 LinkNode *newNode = new LinkNode(x); newNode->link = current->link; current->link = newNode; } } return true; }; • 删除 – 第一种情况: 删除表中第一个元素 – 第二种情况: 删除表中或表尾元素 在单链表中删除含ai的结点 3637 单链表的删除算法 bool List::Remove (int i, int& x) { //将链表中的第 i 个元素删去, i 从1开始。 LinkNode *del; //暂存删除结点指针 if (i <= 1) { del = first; first = first->link; } else { LinkNode *current = first; k = 1; //找i-1号结点 while (k < i-1 && current != NULL) { current = current->link; k++; } if (current == NULL || current->link == NULL) { cout << “无效的删除位置!\\n”; return false; } 38 del = current->link; //删中间/尾结点 current->link = del->link; } x = del->data; delete del; //取出被删结点数据 return true; }; • 实现单链表的插入和删除算法，不需要移动元 素，只需修改结点指针，比顺序表方便。 • 情况复杂，要专门讨论空表和在表头插入的特 殊情形。 • 寻找插入或删除位置只能沿着链顺序检测。 带附加头结点（表头结点）的单链表 • 表头结点位于表的最前端，本身不带 数据，仅标志表头。 • 设置表头结点的目的是统一空表与非 空表的操作，简化链表操作的实现。 非空表 空表 0ana1first first 0 39 在带表头结点的单链表最前端插入新结点 newNode->link = current->link; current->link = newNode; first newNode first newNode 插入 first newNode 0 first newNode 0 插入 current current current current 40 del = current->link; current->link = del->link; delete del; 从带表头结点的单链表中删除最前端的结点 (非空表） (空表） first first first 0first 0 current del current del 41 §2.4 线性链表的其他变形 循环链表 双向链表 42 循环链表 (Circular List) 带表头结点的循环链表 循环链表 43 循环链表的特点： • 循环链表最后一个结点的 link 指针不 为 0 (NULL)，而是指向了表的前端。 • 只要知道表中某一结点的地址，就可 搜寻到所有其他结点的地址。 4445 template <class E> struct CircLinkNode { //链表结点类定义 E data; CircLinkNode<E> *link; CircLinkNode ( CircLinkNode<E> *next = NULL ) { link = next; } CircLinkNode ( E x, CircLinkNode<E> *next = NULL ) { data = x; link = next; } bool Operator==(CircLinkNode<E> & node) { return data == node.data; } bool Operator!=(CircLinkNode<E> & node) { return data != node.data; } }; 循环链表类的定义 46 template <class E> //链表类定义 class CircList : public LinearList<E> { private: CircLinkNode<E> *first, *last; //头指针, 尾指针 public: CircList(const E x); //构造函数 CircList(CircList<E>& L); //复制构造函数 ～CircList(); //析构函数 int Length() const; //计算链表长度 bool IsEmpty() { return first->link == first; } //判表空否 CircLinkNode<E> *getHead() const; //返回表头结点地址 47 void setHead ( CircLinkNode<E> *p ); //设置表头结点地址 CircLinkNode<E> *Search ( E x ); //搜索 CircLinkNode<E> *Locate ( int i );//定位 E *getData ( int i ); //提取 void setData ( int i, E x ); //修改 bool Insert ( int i, E x ); //插入 bool Remove ( int i, E& x); //删除 }; • 循环链表与单链表的操作实现，最主要的不同就 是扫描到链尾，遇到的不是NULL，而是表头。搜索不成功 循环链表的搜索算法 搜索25 搜索成功搜索15 first 31 48 15 57 × × √ current current current first 31 48 15 57 × × × × current current current currentcurrent 48 循环链表的搜索算法 template <class E> CircListNode<E> * CircList<E>::Search( E x ) { //在链表中从头搜索其数据值为 x 的结点 current = first->link; while ( current != first && current->data != x ) current = current->link; return current; } 49 循环链表示例：求解约瑟夫问题 • 约瑟夫问题 （例：n = 8 m = 3） 5051 求解Josephus问题的算法 #include <iostream.h> #include “CircList.h” template <class E> void Josephus(CircList<E>& Js, int n, int m) { CircLinkNode<E> *p = Js.getHead(), *pre = NULL; int i, j; for ( i = 0; i < n-1; i++ ) { //执行n-1次 for ( j = 1; j < m; j++) //数m-1个人 { pre = p; p = p->link; } cout << “出列的人是” << p->data << endl; 52 pre->link = p->link; delete p; //删去 p = pre->link; } }; void main() { CircList< int> clist; int i, n, m; cout << “输入游戏者人数和报数间隔 : ”; cin >> n >> m; for (i = 1; i <= n; i++ ) clist.insert(i, i); //约瑟夫环 Josephus(clist, n, m); //解决约瑟夫问题 } 双向链表（doubly linked list） 前驱方向   后继方向 llLLiinnkk ((左左 链链 指指 针针 )) ddaattaa ((数数 据据 )) rrLLiinnkk ((右右 链链 指指 针针 )) • 每个结点的结构 • 带头结点的双向链表表示 53 • 链表中的结点指针关系 p == p→lLink→rLink == p→rLink→lLink 5455 双向循环链表类的定义 template <class E> struct DblNode { //链表结点类定义 E data; //链表结点数据 DblNode<E> *lLink, *rLink;//前驱、后继指针 DblNode ( DblNode<E> *l = NULL, DblNode<E> *r = NULL ) { lLink = l; rLink = r; } //构造函数 DblNode ( E value, DblNode< E> *l = NULL, DblNode<E> *r = NULL) { data = value; lLink = l; rLink = r; } //构造函数 }; 56 template <class E> class DblList { //链表类定义 public: DblList ( E uniqueVal ) { //构造函数 first = new DblNode<E> (uniqueVal); first->rLink = first->lLink = first; }; DblNode<E> *getFirst () const { return first; } void setFirst ( DblNode<E> *ptr ) { first = ptr; } DblNode<E> *Search ( E x, int d); //在链表中按d指示方向寻找等于给定值x的结点, //d=0按前驱方向,d≠0按后继方向 57 DblNode<E> *Locate ( int i, int d ); //在链表中定位序号为i(≥0)的结点, d=0按前驱方 //向,d≠0按后继方向 bool Insert ( int i, E x, int d ); //在第i个结点后插入一个包含有值x的新结点,d=0 //按前驱方向,d≠0按后继方向 bool Remove ( int i, E& x, int d ); //删除第i个结点 bool IsEmpty() { return first->rlink == first; } //判双链表空否 private: DblNode<E> *first; //表头指针 }; 双向循环链表的搜索算法 搜索成功 搜索不成功 first first 31 31 48 48 15 15 57 57 搜索15 × × √ 搜索25 × × × × 5859 双向循环链表的搜索算法 template <class E> DblNode< E> *DblList<E>::Search (E x, int d) { //在双向循环链表中寻找其值等于x的结点。 DblNode<E> *current = (d == 0)? first->lLink : first->rLink; //按d确定搜索方向 while ( current != first && current->data != x ) current = (d == 0) ? current->lLink : current->rLink; if ( current != first ) return current; //搜索成功 else return NULL; //搜索失败 }; 双向循环链表的插入算法 (非空表) newNode->rLink = current->rLink; current->rLink = newNode; newNode->rLink->lLink = newNode; newNode->lLink = current; first first 31 48 15 后插入25 current newNode 31 48 25 15 current 60 双向循环链表的插入算法 (空表) first 后插入25 current newNode 25first current newNode->rLink = current->rLink (newNode->rLink = first); current->rLink = newNode; newNode->rLink ->lLink = newNode; ( first->lLink = newNode ) newNode->lLink = current; 6162 双向循环链表的插入算法 template <class E> bool DblList<E>::Insert ( int i, E x, int d ) { //建立一个包含有值x的新结点, 并将其按 d 指定的 //方向插入到第i个结点之后。 DblNode< E> *current = Locate(i, d); //按d指示方向查找第i个结点 if ( current == NULL ) return false; //插入失败 DblNode<E> *newNd = new DblNode<E>(x); if (d == 0) { //前驱方向:插在第i个结点左侧 newNd->lLink = current->lLink; //链入lLink链 current->lLink = newNd; 63 newNd->lLink->rLink = newNd; //链入rLink链 newNd->rLink = current; } else { //后继方向:插在第i个结点后面 newNd->rLink = current->rLink; //链入rLink链 current->rLink = newNd; newNd->rLink->lLink = newNd; //链入lLink链 newNd->lLink = current; } return true; //插入成功 }; 删除48 双向循环链表的删除算法 first first 非空表31 48 15 current 31 15 current current->rLink->lLink = current->lLink; current->lLink->rLink = current->rLink; 6465 双向循环链表的删除算法 template < class E> bool DblList< E>::Remove( int i, E& x, int d ) { //在双向循环链表中按d所指方向删除第i个结点。 DblNode< E> *current = Locate (i, d); if (current == NULL) return false; //删除失败 current->rLink->lLink = current->lLink; current->lLink->rLink = current->rLink; //从lLink链和rLink链中摘下 x = current->data; delete current; //删除 return true; //删除成功 }; i n i i n nn xa xaxaxaaxP ∑ = = ++++= 0 2 210 )(   n阶多项式 Pn(x) 有 n+1 项。  系数 a0, a1, a2, …, an  指数 0, 1, 2, …, n。按升幂排列 §2.5 多项式及其运算 A(x) = 1 - 10x6 + 2x8 +7x14 6667 第一种： (静态数组表示) private: int degree; float coef [maxDegree+1]; Pn(x)可以表示为： pl.degree = n pl.coef[i] = ai, 0 ≤ i ≤ n a0 a1 a2 …… an ……… 0 1 2 degree maxDegree-1 coef n 多项式的顺序存储表示 第二种： (动态数组表示) private: int degree; float * coef; Polynomial :: Polynomial (int sz) { maxDegree = sz; coef = new float [maxDegree + 1]; }  以上两种存储表示适用于指数连续排列的多 项式。但对于绝大多数项的系数为零的多项 式，如 P101(x) = 3+5x50-4x101, 不经济。 68 第三种： struct term { //多项式的项定义 float coef; //系数 int exp; //指数 }; static int free, maxTerms; //当前空闲位置指针 static term termArray[maxTerms]; //项数组 a0 a1 a2 …… ai …… am e0 e1 e2 …… ei …… em coef exp 0 1 2 i m 69 初始化： // term Polynomial::termArray[maxTerms]; // int Polynomial::free = 0; class Polynomial { //多项式定义 public: …… private: int start, finish; //多项式始末位置 } 70 两个多项式存储的例子 A(x) = 2.0x1000+1.8 B(x) = 1.2 + 51.3x50 + 3.7x101 两个多项式存放在termArray中 A.start A.finish B.start B.finish free coef exp 1.8 2.0 1.2 51.3 3.7 …… 0 1000 0 50 101 …… maxTerms 71 数据域 指针域 每个结点的结构: A(x) = 1 - 10x6 + 2x8 +7x14 72 第四种：多项式的链表存储表示 73 • 多项式顺序存储表示的缺点 – 插入和删除时项数可能有较大变化，因此要 移动大量数据 – 不利于多个多项式的同时处理 • 多项式链表存储表示的优点 – 多项式的项数可以动态地增长，不存在存储 溢出问题。 – 插入、删除方便，不移动元素 74 多项式(polynomial)类的链表定义 struct Term { //多项式结点定义 float coef; //系数 int exp; //指数 Term *link; //链接指针 Term (float c, int e, Term *next = NULL) { coef = c; exp = e; link = next;} Term *InsertAfter ( float c, int e); friend ostream& operator << (ostream&, const Term& ); }; 75 class Polynomial { //多项式类的定义 public: Polynomal() { first = new Term(0, -1); } //构造函数 Polynomal (Polynomal& R); //复制构造函数 int maxOrder(); //计算最大阶数 private: Term *first; friend ostream& operator << (ostream&, const Polynomal& ); friend istream& operator >> ( istream&, Polynomal& ); 76 friend void Add ( Polynomial& A, Polynomial& B, Polynomial& C ); friend void Mul ( Polynomial& A, Polynomial& B, Polynomial& C ); }; 77 两个多项式的相加算法  设两个多项式都带表头结点，检测指针pa和pb分 别指示两个链表当前检测结点，并设结果多项式的 链表为C，存放指针为pc，初始位置在C的表头结 点。  当pa和pb没有检测完各自的链表时，比较当前检 测结点的指数域：  指数不等：小者加入C链，相应检测指针pa或者 pb进1；  指数相等：对应项系数相加。若相加结果不为 零，则结果加入C链，pa与pb进1。  当pa或pb指针中有一个为NULL，则把另一个链 表的剩余部分加入到C链。 AH.first BH.first ∧ ∧ CH.first ∧ 1 0 1 0 -1 4 -1 4 -3 6 3 6 -9 10 -9 10 7 12 7 12 8 14 8 14 78 多项式链表的相加 AH = 1 - 3x6 + 7x12 BH = - x4 + 3x6 - 9x10 + 8x14 CH = 1 - x4 - 9x10 + 7x12 + 8x14 AH.first BH.first ∧ ∧ CH.first 1 0 -1 4 -3 6 3 6 -9 10 7 12 8 14 pa pc pb ∧ 79 AH.first ∧ ∧ CH.first ∧ 1 0 1 0 -1 4 -3 6 3 6 -9 10 7 12 8 14 pa pb pc BH.first 80 AH.first ∧ ∧ CH.first ∧ 1 0 1 0 -1 4 -1 4 -3 6 3 6 -9 10 7 12 8 14 pa pb pc BH.first 81 AH.first ∧ ∧ CH.first ∧ 1 0 1 0 -1 4 -1 4 -3 6 3 6 -9 10 7 12 8 14 pa pb pc BH.first tmp = -3+3 = 0 82 AH.first ∧ ∧ CH.first 1 0 1 0 -1 4 -1 4 -3 6 3 6 -9 10 7 12 8 14 pa pc -9 10 pbBH.first ∧ 83 AH.first ∧ ∧ CH.first 1 0 1 0 -1 4 -1 4 -3 6 3 6 -9 10 7 12 8 14 pa pc -9 10 pbBH.first 7 12 ∧ 84 AH.first ∧ ∧ CH.first 1 0 1 0 -1 4 -1 4 -3 6 3 6 -9 10 7 12 8 14 pa pc -9 10 pbBH.first 7 12 8 14 ∧ p 85 §2.6 静态链表 为数组中每一个元素附加一个链接指针，就形成静 态链表结构。 静态链表每个结点由两个数据成员构成：data域存 储数据，link域存放链接指针。 处理时可以不改变各元素的物理位置，只要重新链 接就能改变这些元素的逻辑顺序。 它是利用数组定义的，在整个运算过程中存储空间 的大小不会变化。 8687 静态链表的结构 • 0号是表头结点，link给出首元结点地址。 • 循环链表收尾时link = 0，回到表头结点。如果不是 循环链表，收尾结点指针link = -1。 • link指针是数组下标，因此是整数。 0 1 2 3 4 5 data a3 a4 a1 a5 a2 link 3 2 4 5 -1(0) 1 a1 a2 a3 a4 a5 Λfirst","libVersion":"0.2.4","langs":""}