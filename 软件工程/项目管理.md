## 构建系统

- 系统的任务则是找到构建目标所需要的依赖，并根据规则构建所需的中间产物，直到**最终目标被构建出来**。

### make

- Makefile示例

  - ```makefile
    paper.pdf: paper.tex plot-data.png
    	pdflatex paper.tex
    
    plot-%.png: %.dat plot.py
    	./plot.py -i $*.dat -o $@
    ```

  - 冒号**左侧**的是**构建目标**，冒号**右侧**的是构建它所需的**依赖**，**缩进**的部分是从依赖构建目标时需要**用到的一段命令**。

  - **第一条指令还指明了默认构建的目的**，或者可以使用这样的命令来构建其他目标：`make plot-data.png`。

  -  `%` 是一种模式，它会匹配其左右两侧相同的字符串。例如，如果目标是 `plot-foo.png`， `make` 会去寻找 `foo.dat` 和 `plot.py` 作为依赖。

- 修改文件后会根据依赖关系对需要的部分进行更新

## 依赖管理

- 版本管理
  - 软件包的更新可能造成方法、接口的改变，很可能导致构建失败，因为它希望调用的函数已经不复存在了。
  - 有了版本控制就可以很好的解决这个问题，我们可以**指定当前项目需要基于某个版本**，甚至某个范围内的版本，或是某些项目来构建。
- 版本号
  - 如果新的版本**没有改变 API**，请将**补丁号**递增；
  - 如果您添加了 API 并且该改动是**向后兼容的**，请将**次版本号**递增；
  - 如果您修改了 API 但是它并**不向后兼容**，请将**主版本号**递增。
- 如果我们的项目是基于别项目构建的，那么只要最新版本的**主版本号只要没变**就是安全的 ，**次版本号不低于**之前我们使用的版本即可。
  - 如果我依赖的版本是`1.3.7`，那么使用`1.3.8`、`1.6.1`，甚至是`1.3.0`都是可以的。
- 锁文件
  - 锁文件列出了您当前每个依赖所对应的**具体版本号**。
  - 需要**执行升级程序**才能更新依赖的版本。
    - 避免不必要的重新编译、创建可复现的软件版本或禁止自动升级到最新版本
    - 确保可重复的结果
  - 锁文件通常是自动生成的，并且应该与项目代码一起检入版本控制系统。当其他开发者或者部署流程检出代码库时，锁文件会被用来安装确定的依赖版本，以确保所有人都在相同的开发环境下工作，减少了“在我机器上能运行”的问题。

冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖

## 持续集成

- 在代码仓库中添加一个文件，描述当前仓库发生任何修改时，应该如何应对。
- 如当有人提交代码，执行测试套件。