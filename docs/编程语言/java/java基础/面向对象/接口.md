
- `private Linable linable;`其中Linable是一个接口，作为类的成员变量
- 接口不能直接实例化，它只能通过实现该接口的类来创建对象
- 接口是对类的一种形容词，而抽象类是类层次结构的一部分

- 语法
  - `interface 接口名 {} `
  - `public class 类名 implements 接口名 {}`
  - **一个类可以继承一个类的同时实现多个接口**
  - 接口之间可以单继承也可以多继承
    - 有重复方法也无所谓，因为**就是都实现了，不存在冲突**

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230920230013866.png" alt="image-20230920230013866" style="zoom:50%;" />

  - 接口中的**成员变量**实际上是public final static的**静态常量**，按照命名规范应该使用全大写字母以及_划分

- 默认方法：`public default void show() {}`加上default关键字后就不是抽象方法了，**可以不重写**，如果要重写只需要在重写时去掉default，如果继承的**多个接口中有相同的声明则必须重写**（也可以使用super直接选一个）
  - 对于重名的常量则不会有问题，因为类不会从接口继承常量，常量必须通过接口名进行显式访问

- 实现接口中的方法必须显式声明为public（默认也会是public）

- public接口像类一样，只能出现在相同名称的文件

- 接口中的静态方法
  - 在接口包含逻辑上属于它的实用工具
  - 接口的静态方法必须通过接口本身进行调用（这与常量成员是相同的）

  - 接口**之间**是可以多继承的（即extends后面跟多个）
  - 注意多继承的接口中不应有**重名，参数相同但是返回值不同**的方法
  - private接口允许嵌套在类内
  - 类内实现private接口的类可以为public，但是禁止向上转型
  - public方法返回private接口的引用也会被禁止使用


- 接口的private方法JDK9
  - private表示只想自己使用的方法
  - private方法也是default的

- **密封类和密封接口**JDK17
  - 基类和接口可以限制自己能派生哪些类型
  - 在基类/接口中指出允许的子类`sealed class Base permits D1, D2{}`
  - 如果表示只让同一文件存在子类，只需要使用`sealed`即可
  - 必须至少有一个子类
  - 只是限制直接子类，如果直接子类使用`non-sealed`则可以有任意间接子类
  - 常用于switch，可以免default

#### [[函数式编程#函数式接口|函数式接口]]

#### 接口的应用

- 接口-完全解耦
  - 使用接口作为变量类型限制（[[设计模式#策略模式|策略模式]]）

- [[设计模式#适配器模式|适配器模式]]
  - 有时不方便（无法）对类进行修改，使用适配器，将已有的接口转化为需要的接口，也可以为不满足接口的类添加方法，使得满足接口的要求